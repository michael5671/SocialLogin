/*!
 * devextreme-react
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-react
 */

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConfigBuilder = exports.buildNodeFullName = void 0;
const React = __importStar(require("react"));
const widget_config_1 = require("../widget-config");
const templates_1 = require("./react/templates");
const contexts_1 = require("../contexts");
function buildNodeFullName(node) {
    let currentNode = node;
    let fullName = '';
    while (currentNode && currentNode.name) {
        fullName = currentNode.name.concat(typeof currentNode.index === 'number' ? `[${currentNode.index}]` : '', fullName ? `.${fullName}` : '');
        currentNode = currentNode.parentNode;
    }
    return fullName;
}
exports.buildNodeFullName = buildNodeFullName;
const renderContextValue = {
    isTemplateRendering: true,
};
const createConfigBuilder = (optionElement, parentFullName) => {
    const separatedValues = (0, widget_config_1.separateProps)(optionElement.props, optionElement.descriptor.initialValuesProps, optionElement.descriptor.templates);
    return {
        node: {
            name: optionElement.descriptor.name,
            predefinedOptions: optionElement.descriptor.predefinedValuesProps,
            initialOptions: separatedValues.defaults,
            options: separatedValues.options,
            templates: [],
            configCollections: {},
            configs: {},
        },
        configCollectionMaps: {},
        getConfigCollectionData(name) {
            if (!this.node.configCollections[name]) {
                this.node.configCollections[name] = [];
                this.configCollectionMaps[name] = {};
            }
            return [this.node.configCollections[name], this.configCollectionMaps[name]];
        },
        addChildNode(name, childNode) {
            childNode.parentNode = this.node;
            this.node.configs[name] = childNode;
        },
        addCollectionNode(name, collectionNode, collectionNodeKey) {
            const [collection, collectionMap] = this.getConfigCollectionData(name);
            const itemIndex = collectionMap[collectionNodeKey] ?? collection.length;
            collectionNode.index = itemIndex;
            collectionNode.parentNode = this.node;
            if (itemIndex < collection.length) {
                collection[itemIndex] = collectionNode;
            }
            else {
                collectionMap[collectionNodeKey] = itemIndex;
                collection.push(collectionNode);
            }
        },
        addTemplate(template) {
            this.node.templates.push(template);
        },
        updateAnonymousTemplates(hasTemplateRendered) {
            this.node.templates = this.node.templates.filter((template) => !template.isAnonymous);
            optionElement.descriptor.templates.forEach((templateMeta) => {
                const template = (0, templates_1.getAnonymousTemplate)(optionElement.props, templateMeta, hasTemplateRendered && (optionElement.descriptor.isCollection || parentFullName.length > 0));
                if (template) {
                    this.node.templates.push(this.wrapTemplate(template));
                }
            });
        },
        wrapTemplate(template) {
            return template.type === 'children' ? {
                ...template,
                content: React.createElement(contexts_1.TemplateRenderingContext.Provider, {
                    value: renderContextValue,
                }, template.content),
            } : template;
        },
    };
};
exports.createConfigBuilder = createConfigBuilder;
