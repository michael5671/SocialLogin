/*!
 * devextreme-react
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-react
 */

import * as React from 'react';
import { separateProps } from '../widget-config';
import { getAnonymousTemplate } from './react/templates';
import { TemplateRenderingContext } from '../contexts';
function buildNodeFullName(node) {
    let currentNode = node;
    let fullName = '';
    while (currentNode && currentNode.name) {
        fullName = currentNode.name.concat(typeof currentNode.index === 'number' ? `[${currentNode.index}]` : '', fullName ? `.${fullName}` : '');
        currentNode = currentNode.parentNode;
    }
    return fullName;
}
const renderContextValue = {
    isTemplateRendering: true,
};
const createConfigBuilder = (optionElement, parentFullName) => {
    const separatedValues = separateProps(optionElement.props, optionElement.descriptor.initialValuesProps, optionElement.descriptor.templates);
    return {
        node: {
            name: optionElement.descriptor.name,
            predefinedOptions: optionElement.descriptor.predefinedValuesProps,
            initialOptions: separatedValues.defaults,
            options: separatedValues.options,
            templates: [],
            configCollections: {},
            configs: {},
        },
        configCollectionMaps: {},
        getConfigCollectionData(name) {
            if (!this.node.configCollections[name]) {
                this.node.configCollections[name] = [];
                this.configCollectionMaps[name] = {};
            }
            return [this.node.configCollections[name], this.configCollectionMaps[name]];
        },
        addChildNode(name, childNode) {
            childNode.parentNode = this.node;
            this.node.configs[name] = childNode;
        },
        addCollectionNode(name, collectionNode, collectionNodeKey) {
            const [collection, collectionMap] = this.getConfigCollectionData(name);
            const itemIndex = collectionMap[collectionNodeKey] ?? collection.length;
            collectionNode.index = itemIndex;
            collectionNode.parentNode = this.node;
            if (itemIndex < collection.length) {
                collection[itemIndex] = collectionNode;
            }
            else {
                collectionMap[collectionNodeKey] = itemIndex;
                collection.push(collectionNode);
            }
        },
        addTemplate(template) {
            this.node.templates.push(template);
        },
        updateAnonymousTemplates(hasTemplateRendered) {
            this.node.templates = this.node.templates.filter((template) => !template.isAnonymous);
            optionElement.descriptor.templates.forEach((templateMeta) => {
                const template = getAnonymousTemplate(optionElement.props, templateMeta, hasTemplateRendered && (optionElement.descriptor.isCollection || parentFullName.length > 0));
                if (template) {
                    this.node.templates.push(this.wrapTemplate(template));
                }
            });
        },
        wrapTemplate(template) {
            return template.type === 'children' ? {
                ...template,
                content: React.createElement(TemplateRenderingContext.Provider, {
                    value: renderContextValue,
                }, template.content),
            } : template;
        },
    };
};
export { buildNodeFullName, createConfigBuilder, };
