/*!
 * devextreme-react
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-react
 */

import { useContext, useRef, useLayoutEffect, } from 'react';
import { mergeNameParts } from './configuration/utils';
import { createConfigBuilder } from './configuration/config-node';
import { NestedOptionContext } from './contexts';
export function useOptionScanning(optionElement, getHasTemplate, parentUpdateToken, parentType) {
    const parentContext = useContext(NestedOptionContext);
    const { parentFullName, } = parentContext;
    const updateToken = Symbol('update token');
    const configBuilder = createConfigBuilder(optionElement, parentFullName);
    const childComponentCounter = useRef(0);
    const context = {
        parentExpectedChildren: optionElement.descriptor.expectedChildren,
        parentFullName: mergeNameParts(parentFullName, optionElement.descriptor.name),
        parentType,
        treeUpdateToken: updateToken,
        getOptionComponentKey: () => {
            childComponentCounter.current += 1;
            return childComponentCounter.current;
        },
        onNamedTemplateReady: (template, childUpdateToken) => {
            if (childUpdateToken !== updateToken) {
                return;
            }
            if (template) {
                configBuilder.addTemplate(template);
            }
        },
        onChildOptionsReady: (childConfigNode, childDescriptor, childUpdateToken, childComponentKey) => {
            if (childUpdateToken !== updateToken) {
                return;
            }
            const { isCollection, name } = childDescriptor;
            if (isCollection) {
                configBuilder.addCollectionNode(name, childConfigNode, childComponentKey);
                return;
            }
            configBuilder.addChildNode(name, childConfigNode);
        },
    };
    useLayoutEffect(() => {
        configBuilder.updateAnonymousTemplates(getHasTemplate());
    }, [parentUpdateToken]);
    return [configBuilder.node, context];
}
