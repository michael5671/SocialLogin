/**
 * DevExtreme (cjs/__internal/ui/list/m_list.edit.strategy.grouped.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _query = _interopRequireDefault(require("../../../common/data/query"));
var _store_helper = _interopRequireDefault(require("../../../common/data/store_helper"));
var _renderer = _interopRequireDefault(require("../../../core/renderer"));
var _iterator = require("../../../core/utils/iterator");
var _type = require("../../../core/utils/type");
var _m_collection_widgetEditStrategy = _interopRequireDefault(require("../../ui/collection/m_collection_widget.edit.strategy.plain"));

function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}
const LIST_ITEM_CLASS = "dx-list-item";
const LIST_GROUP_CLASS = "dx-list-group";
const SELECTION_SHIFT = 20;
const SELECTION_MASK = 1048575;
const combineIndex = indices => (indices.group << 20) + indices.item;
const splitIndex = combinedIndex => ({
    group: combinedIndex >> 20,
    item: 1048575 & combinedIndex
});
class GroupedEditStrategy extends _m_collection_widgetEditStrategy.default {
    _groupElements() {
        return this._collectionWidget._itemContainer().find(".dx-list-group")
    }
    _groupItemElements($group) {
        return $group.find(".dx-list-item")
    }
    getIndexByItemData(itemData) {
        var _itemData$items;
        const groups = this._collectionWidget.option("items");
        let index = false;
        if (!itemData) {
            return false
        }
        if (null !== (_itemData$items = itemData.items) && void 0 !== _itemData$items && _itemData$items.length) {
            itemData = itemData.items[0]
        }(0, _iterator.each)(groups, ((groupIndex, group) => {
            if (!group.items) {
                return false
            }(0, _iterator.each)(group.items, ((itemIndex, item) => {
                if (item !== itemData) {
                    return true
                }
                index = {
                    group: groupIndex,
                    item: itemIndex
                };
                return false
            }));
            if (index) {
                return false
            }
        }));
        return index
    }
    getItemDataByIndex(index) {
        var _items$index$group;
        const items = this._collectionWidget.option("items");
        if ((0, _type.isNumeric)(index)) {
            return this.itemsGetter()[index]
        }
        return index && (null === (_items$index$group = items[index.group]) || void 0 === _items$index$group ? void 0 : _items$index$group.items[index.item]) || null
    }
    itemsGetter() {
        let resultItems = [];
        const {
            items: items
        } = this._collectionWidget.option();
        for (let i = 0; i < items.length; i++) {
            var _items$i;
            if (null !== (_items$i = items[i]) && void 0 !== _items$i && _items$i.items) {
                resultItems = resultItems.concat(items[i].items)
            } else {
                resultItems.push(items[i])
            }
        }
        return resultItems
    }
    deleteItemAtIndex(index) {
        const indices = splitIndex(index);
        const itemGroup = this._collectionWidget.option("items")[indices.group].items;
        itemGroup.splice(indices.item, 1)
    }
    getKeysByItems(items) {
        let plainItems = [];
        let i;
        for (i = 0; i < items.length; i++) {
            var _items$i2;
            if (null !== (_items$i2 = items[i]) && void 0 !== _items$i2 && _items$i2.items) {
                plainItems = plainItems.concat(items[i].items)
            } else {
                plainItems.push(items[i])
            }
        }
        const result = [];
        for (i = 0; i < plainItems.length; i++) {
            result.push(this._collectionWidget.keyOf(plainItems[i]))
        }
        return result
    }
    getIndexByKey(key, items) {
        const groups = items || this._collectionWidget.option("items");
        let index = -1;
        const that = this;
        (0, _iterator.each)(groups, ((groupIndex, group) => {
            if (!group.items) {
                return
            }(0, _iterator.each)(group.items, ((itemIndex, item) => {
                const itemKey = that._collectionWidget.keyOf(item);
                if (that._equalKeys(itemKey, key)) {
                    index = {
                        group: groupIndex,
                        item: itemIndex
                    };
                    return false
                }
            }));
            if (-1 !== index) {
                return false
            }
        }));
        return index
    }
    _getGroups(items) {
        const dataController = this._collectionWidget._dataController;
        const group = dataController.group();
        if (group) {
            return _store_helper.default.queryByOptions((0, _query.default)(items), {
                group: group
            }).toArray()
        }
        return this._collectionWidget.option("items")
    }
    getItemsByKeys(keys, items) {
        const result = [];
        const groups = this._getGroups(items);
        const groupItemByKeyMap = {};
        const getItemMeta = key => {
            const index = this.getIndexByKey(key, groups);
            const group = index && groups[index.group];
            if (!group) {
                return
            }
            return {
                groupKey: group.key,
                item: group.items[index.item]
            }
        };
        (0, _iterator.each)(keys, ((_, key) => {
            const itemMeta = getItemMeta(key);
            if (!itemMeta) {
                return
            }
            const {
                groupKey: groupKey
            } = itemMeta;
            const {
                item: item
            } = itemMeta;
            let selectedGroup = groupItemByKeyMap[groupKey];
            if (!selectedGroup) {
                selectedGroup = {
                    key: groupKey,
                    items: []
                };
                groupItemByKeyMap[groupKey] = selectedGroup;
                result.push(selectedGroup)
            }
            selectedGroup.items.push(item)
        }));
        return result
    }
    moveItemAtIndexToIndex(movingIndex, destinationIndex) {
        const items = this._collectionWidget.option("items");
        const movingIndices = splitIndex(movingIndex);
        const destinationIndices = splitIndex(destinationIndex);
        const movingItemGroup = items[movingIndices.group].items;
        const destinationItemGroup = items[destinationIndices.group].items;
        const movedItemData = movingItemGroup[movingIndices.item];
        movingItemGroup.splice(movingIndices.item, 1);
        destinationItemGroup.splice(destinationIndices.item, 0, movedItemData)
    }
    _isItemIndex(index) {
        return index && (0, _type.isNumeric)(index.group) && (0, _type.isNumeric)(index.item)
    }
    _getNormalizedItemIndex(itemElement) {
        const $item = (0, _renderer.default)(itemElement);
        const $group = $item.closest(".dx-list-group");
        if (!$group.length) {
            return -1
        }
        return combineIndex({
            group: this._groupElements().index($group),
            item: this._groupItemElements($group).index($item)
        })
    }
    _normalizeItemIndex(index) {
        return combineIndex(index)
    }
    _denormalizeItemIndex(index) {
        return splitIndex(index)
    }
    _getItemByNormalizedIndex(index) {
        const indices = splitIndex(index);
        const $group = this._groupElements().eq(indices.group);
        return this._groupItemElements($group).eq(indices.item)
    }
    _itemsFromSameParent(firstIndex, secondIndex) {
        return splitIndex(firstIndex).group === splitIndex(secondIndex).group
    }
}
var _default = exports.default = GroupedEditStrategy;
