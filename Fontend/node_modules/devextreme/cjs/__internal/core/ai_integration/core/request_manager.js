/**
 * DevExtreme (cjs/__internal/core/ai_integration/core/request_manager.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RequestManager = void 0;
var _errors = _interopRequireDefault(require("../../../../core/errors"));

function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}
class RequestManager {
    constructor(provider) {
        this.provider = provider;
        this.validateProvider()
    }
    validateProvider() {
        if ("function" !== typeof this.provider.sendRequest) {
            throw _errors.default.Error("E0122")
        }
    }
    sendRequest(prompt, callbacks) {
        let aborted = false;
        const params = {
            prompt: prompt,
            onChunk: chunk => {
                if (!aborted) {
                    var _callbacks$onChunk;
                    null === callbacks || void 0 === callbacks || null === (_callbacks$onChunk = callbacks.onChunk) || void 0 === _callbacks$onChunk || _callbacks$onChunk.call(callbacks, chunk)
                }
            }
        };
        const {
            promise: promise,
            abort: abortRequest
        } = this.provider.sendRequest(params);
        promise.then((response => {
            if (!aborted) {
                var _callbacks$onComplete;
                null === callbacks || void 0 === callbacks || null === (_callbacks$onComplete = callbacks.onComplete) || void 0 === _callbacks$onComplete || _callbacks$onComplete.call(callbacks, response)
            }
        })).catch((e => {
            if (!aborted) {
                var _callbacks$onError;
                null === callbacks || void 0 === callbacks || null === (_callbacks$onError = callbacks.onError) || void 0 === _callbacks$onError || _callbacks$onError.call(callbacks, e)
            }
        }));
        return () => {
            aborted = true;
            null === abortRequest || void 0 === abortRequest || abortRequest()
        }
    }
}
exports.RequestManager = RequestManager;
