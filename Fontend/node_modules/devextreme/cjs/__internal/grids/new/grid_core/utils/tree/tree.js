/**
 * DevExtreme (cjs/__internal/grids/new/grid_core/utils/tree/tree.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.shallowCopyTree = exports.shallowCopySubtreePath = exports.setTreeNodeByPath = exports.mergeOptionTrees = exports.getTreeNodeParentByPath = exports.getTreeNodeByPath = exports.deepMergeTrees = exports.deepCopyTreeNode = exports.createOrShallowCopySubtreePath = void 0;
var _m_extend = require("../../../../../core/utils/m_extend");
var _m_type = require("../../../../../core/utils/m_type");

function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) {
                ({}).hasOwnProperty.call(t, r) && (n[r] = t[r])
            }
        }
        return n
    }, _extends.apply(null, arguments)
}
const shallowCopyTree = tree => {
    if ((0, _m_type.isPlainObject)(tree)) {
        return _extends({}, tree)
    }
    if (Array.isArray(tree)) {
        return [...tree]
    }
    return tree
};
exports.shallowCopyTree = shallowCopyTree;
const deepCopyTreeNode = treeNode => {
    switch (true) {
        case (0, _m_type.isPlainObject)(treeNode):
            return (0, _m_extend.extend)(true, {}, treeNode);
        case Array.isArray(treeNode):
            return (0, _m_extend.extend)(true, [], treeNode);
        default:
            return treeNode
    }
};
exports.deepCopyTreeNode = deepCopyTreeNode;
const deepMergeTrees = (firstTree, secondTree) => {
    if ((0, _m_type.isPlainObject)(secondTree) && (0, _m_type.isPlainObject)(firstTree)) {
        return (0, _m_extend.extend)(true, {}, firstTree, secondTree)
    }
    if (void 0 !== secondTree) {
        return deepCopyTreeNode(secondTree)
    }
    return deepCopyTreeNode(firstTree)
};
exports.deepMergeTrees = deepMergeTrees;
const getTreeNodeParentByPath = (tree, path) => {
    let currentNode = tree;
    for (let idx = 0; idx < path.length - 1; idx += 1) {
        const nextNodePath = path[idx];
        currentNode = currentNode[nextNodePath];
        if (void 0 === currentNode) {
            return
        }
    }
    return currentNode
};
exports.getTreeNodeParentByPath = getTreeNodeParentByPath;
const getTreeNodeByPath = (tree, path) => {
    const [lastNodePath] = path.slice(-1);
    const subtree = getTreeNodeParentByPath(tree, path);
    return null === subtree || void 0 === subtree ? void 0 : subtree[lastNodePath]
};
exports.getTreeNodeByPath = getTreeNodeByPath;
const shallowCopySubtreePath = (tree, path) => {
    const shallowCopiedTree = shallowCopyTree(tree);
    let currentNode = shallowCopiedTree;
    for (let idx = 0; idx < path.length - 1; idx += 1) {
        var _currentNode;
        const nextNodePath = path[idx];
        const nextNode = null === (_currentNode = currentNode) || void 0 === _currentNode ? void 0 : _currentNode[nextNodePath];
        if (void 0 === nextNode) {
            break
        }
        currentNode[nextNodePath] = shallowCopyTree(nextNode);
        currentNode = nextNode
    }
    return shallowCopiedTree
};
exports.shallowCopySubtreePath = shallowCopySubtreePath;
const createOrShallowCopySubtreePath = (tree, path) => {
    const shallowCopiedTree = shallowCopyTree(tree);
    let currentNode = shallowCopiedTree;
    for (let idx = 0; idx < path.length; idx += 1) {
        const isLastPath = idx === path.length - 1;
        const nextNodePath = path[idx];
        if (void 0 === currentNode[nextNodePath]) {
            currentNode[nextNodePath] = !isLastPath ? {} : void 0
        } else {
            currentNode[nextNodePath] = shallowCopyTree(currentNode[nextNodePath])
        }
        currentNode = currentNode[nextNodePath]
    }
    return shallowCopiedTree
};
exports.createOrShallowCopySubtreePath = createOrShallowCopySubtreePath;
const mergeOptionTrees = (internalTree, publicTree, defaultTree, pathToMerge) => {
    const [lastNodePath] = pathToMerge.slice(-1);
    const result = createOrShallowCopySubtreePath(internalTree, pathToMerge);
    const targetNodeParent = getTreeNodeParentByPath(result, pathToMerge);
    const newNodeValue = getTreeNodeByPath(publicTree, pathToMerge);
    const defaultNodeValue = getTreeNodeByPath(defaultTree, pathToMerge);
    targetNodeParent[lastNodePath] = deepMergeTrees(defaultNodeValue, newNodeValue);
    return result
};
exports.mergeOptionTrees = mergeOptionTrees;
const setTreeNodeByPath = (tree, node, path) => {
    const [lastNodePath] = path.slice(-1);
    const shallowCopiedTree = createOrShallowCopySubtreePath(tree, path);
    const subtree = getTreeNodeParentByPath(shallowCopiedTree, path);
    subtree[lastNodePath] = node;
    return shallowCopiedTree
};
exports.setTreeNodeByPath = setTreeNodeByPath;
