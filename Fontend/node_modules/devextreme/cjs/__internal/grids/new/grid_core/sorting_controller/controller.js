/**
 * DevExtreme (cjs/__internal/grids/new/grid_core/sorting_controller/controller.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SortingController = void 0;
var _signalsCore = require("@preact/signals-core");
var _index = require("../columns_controller/index");
var _utils = require("../columns_controller/utils");
var _options_controller = require("../options_controller/options_controller");
var _utils2 = require("./utils");

function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) {
                ({}).hasOwnProperty.call(t, r) && (n[r] = t[r])
            }
        }
        return n
    }, _extends.apply(null, arguments)
}
class SortingController {
    constructor(options, columnsController) {
        this.options = options;
        this.columnsController = columnsController;
        this.ascendingText = this.options.oneWay("sorting.ascendingText");
        this.clearText = this.options.oneWay("sorting.clearText");
        this.descendingText = this.options.oneWay("sorting.descendingText");
        this.mode = this.options.oneWay("sorting.mode");
        this._showSortIndexes = this.options.oneWay("sorting.showSortIndexes");
        this.sortedColumns = (0, _signalsCore.computed)((() => this.columnsController.visibleColumns.value.filter((column => column.sortOrder))));
        this.orderedSortedColumns = (0, _signalsCore.computed)((() => {
            const columns = this.sortedColumns.value;
            const mode = this.mode.value;
            const result = columns.sort(_utils2.sortOrderDelegate);
            if ("multiple" !== mode && this.areColumnsInitialized) {
                return result
            }
            if (!this.areColumnsInitialized) {
                this.areColumnsInitialized = true;
                result.forEach(((col, idx) => {
                    this.columnsController.columnOption(col, "sortIndex", idx)
                }))
            }
            return result
        }));
        this.showSortIndexes = (0, _signalsCore.computed)((() => {
            const _showSortIndexes = this._showSortIndexes.value;
            const sortedColumns = this.sortedColumns.value;
            if (!_showSortIndexes) {
                return _showSortIndexes
            }
            return sortedColumns.length > 1
        }));
        this.sortParameters = (0, _signalsCore.computed)((() => {
            const columns = this.orderedSortedColumns.value;
            const result = [];
            columns.forEach((c => {
                const sortItem = {
                    selector: c.calculateSortValue ?? c.dataField ?? c.selector,
                    desc: "desc" === c.sortOrder
                };
                if (c.sortingMethod) {
                    sortItem.compare = c.sortingMethod.bind(c)
                }
                result.push(sortItem)
            }));
            return result
        }));
        this.areColumnsInitialized = false
    }
    clearSorting() {
        this.columnsController.updateColumns((columns => columns.map((c => {
            delete c.sortOrder;
            delete c.sortIndex;
            return c
        }))))
    }
    onSingleModeSortClick(column, e) {
        if (!column.allowSorting) {
            return
        }
        const isCtrl = e.ctrlKey || e.metaKey;
        const isClearSorting = !!column.sortOrder && isCtrl;
        if (isClearSorting) {
            this.clearSorting();
            return
        }
        const isClearSortingRequired = !column.sortOrder && !isCtrl || this.sortedColumns.peek().length > 1;
        const nextSortOrder = (0, _utils2.getNextSortOrder)(column.sortOrder, isCtrl);
        this.onSingleModeSortCore(column, isClearSortingRequired, nextSortOrder)
    }
    onSingleModeSortCore(column, isClearSortingRequired, nextSortOrder) {
        (0, _signalsCore.batch)((() => {
            if (isClearSortingRequired) {
                this.clearSorting()
            }
            this.columnsController.columnOption(column, "sortOrder", nextSortOrder)
        }))
    }
    onMultipleModeSortClick(column, e) {
        if (!column.allowSorting) {
            return
        }
        const isCtrl = e.ctrlKey || e.metaKey;
        const hasNothingToChange = !column.sortOrder && isCtrl && !e.shiftKey;
        if (hasNothingToChange) {
            return
        }
        const nextSortOrder = (0, _utils2.getNextSortOrder)(column.sortOrder, isCtrl);
        const isClearSortingRequired = !isCtrl && !e.shiftKey;
        this.onMultipleModeSortCore(column, isClearSortingRequired, nextSortOrder)
    }
    onMultipleModeSortCore(column, isClearSortingRequired, nextSortOrder) {
        (0, _signalsCore.batch)((() => {
            if (isClearSortingRequired) {
                this.clearSorting()
            }
            this.updateColumnSortOrder(column, nextSortOrder)
        }))
    }
    updateColumnSortOrder(column, nextSortOrder) {
        const needChanges = "multiple" === this.mode.peek();
        if (!needChanges) {
            return
        }
        this.columnsController.updateColumns((columns => {
            const newColumns = [...columns];
            let needNormalizing = false;
            const orderedSortedColumns = this.orderedSortedColumns.peek();
            const orderedIndex = (0, _utils.getColumnIndexByName)(orderedSortedColumns, column.name);
            const commonIndex = (0, _utils.getColumnIndexByName)(newColumns, column.name);
            newColumns[commonIndex].sortOrder = nextSortOrder;
            if (!!nextSortOrder && -1 === orderedIndex) {
                orderedSortedColumns.push(newColumns[commonIndex]);
                needNormalizing = true
            }
            if (!nextSortOrder && orderedIndex > -1) {
                delete newColumns[commonIndex].sortOrder;
                delete newColumns[commonIndex].sortIndex;
                orderedSortedColumns.splice(orderedIndex, 1);
                needNormalizing = true
            }
            if (needNormalizing) {
                let counter = 0;
                orderedSortedColumns.forEach((c => {
                    const index = (0, _utils.getColumnIndexByName)(newColumns, c.name);
                    if (newColumns[index].sortIndex !== counter) {
                        newColumns[index] = _extends({}, newColumns[index], {
                            sortIndex: counter
                        })
                    }
                    counter += 1
                }))
            }
            return newColumns
        }))
    }
}
exports.SortingController = SortingController;
SortingController.dependencies = [_options_controller.OptionsController, _index.ColumnsController];
