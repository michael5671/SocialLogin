/**
 * DevExtreme (cjs/__internal/grids/new/grid_core/keyboard_navigation/options.intergration.test.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
var _globals = require("@jest/globals");
var _renderer = _interopRequireDefault(require("../../../../../core/renderer"));
var _widget = _interopRequireDefault(require("../../../../grids/new/card_view/widget"));
var _inferno = require("inferno");

function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}

function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) {
                ({}).hasOwnProperty.call(t, r) && (n[r] = t[r])
            }
        }
        return n
    }, _extends.apply(null, arguments)
}
const SELECTORS = {
    cardView: ".dx-cardview",
    headerPanelContent: ".dx-cardview-headerpanel-content",
    headerItem: ".dx-cardview-header-item",
    cardContainer: ".dx-cardview-content",
    card: ".dx-cardview-card",
    cardContent: ".dx-cardview-card-content"
};
const ATTRS = {
    focusDecoy: "data-dx-focus-decoy",
    focusTrapContent: "data-dx-focus-trap-content"
};
const rootQuerySelector = selector => document.body.querySelector(selector);
const setup = function() {
    let options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const container = document.createElement("div");
    const {
        body: body
    } = document;
    body.append(container);
    const cardView = new _widget.default(container, options);
    (0, _inferno.rerender)();
    return {
        container: container,
        cardView: cardView
    }
};
const baseConfig = {
    dataSource: new Array(6).fill(null).map(((_, idx) => ({
        id: idx
    }))),
    keyExpr: "id",
    columns: ["id"]
};
(0, _globals.describe)("Options", (() => {
    (0, _globals.afterEach)((() => {
        var _$;
        const cardView = rootQuerySelector(SELECTORS.cardView);
        null === (_$ = (0, _renderer.default)(cardView ?? void 0)) || void 0 === _$ || _$.dxCardView("dispose")
    }));
    (0, _globals.describe)("KeyboardNavigation", (() => {
        (0, _globals.describe)("enabled: true", (() => {
            (0, _globals.it)("header items should contain tabindex=0", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    }
                }));
                const headerItem = container.querySelector(SELECTORS.headerItem);
                (0, _globals.expect)(null === headerItem || void 0 === headerItem ? void 0 : headerItem.getAttribute("tabindex")).toBe("0")
            }));
            (0, _globals.it)("header items container should render focus decoys", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    }
                }));
                const headerPanelContent = container.querySelector(SELECTORS.headerPanelContent);
                const parentContainer = null === headerPanelContent || void 0 === headerPanelContent ? void 0 : headerPanelContent.parentElement;
                const firstDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.firstElementChild;
                const lastDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.lastElementChild;
                (0, _globals.expect)(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute("tabindex")).toBe("0");
                (0, _globals.expect)(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute(ATTRS.focusDecoy)).toBe("true");
                (0, _globals.expect)(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute("tabindex")).toBe("0");
                (0, _globals.expect)(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute(ATTRS.focusDecoy)).toBe("true")
            }));
            (0, _globals.it)("cards should contain tabindex=0", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    }
                }));
                const card = container.querySelector(SELECTORS.card);
                (0, _globals.expect)(null === card || void 0 === card ? void 0 : card.getAttribute("tabindex")).toBe("0")
            }));
            (0, _globals.it)("card content should render focus trap container", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    }
                }));
                const cardContent = container.querySelector(SELECTORS.cardContent);
                const focusTrapNode = null === cardContent || void 0 === cardContent ? void 0 : cardContent.parentElement;
                (0, _globals.expect)(null === focusTrapNode || void 0 === focusTrapNode ? void 0 : focusTrapNode.getAttribute(ATTRS.focusTrapContent)).toBe("true")
            }));
            (0, _globals.it)("card content should render focus decoys", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    }
                }));
                const cardContent = container.querySelector(SELECTORS.cardContent);
                const parentContainer = null === cardContent || void 0 === cardContent ? void 0 : cardContent.parentElement;
                const firstDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.firstElementChild;
                const lastDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.lastElementChild;
                (0, _globals.expect)(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute("tabindex")).toBe("0");
                (0, _globals.expect)(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute(ATTRS.focusDecoy)).toBe("true");
                (0, _globals.expect)(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute("tabindex")).toBe("0");
                (0, _globals.expect)(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute(ATTRS.focusDecoy)).toBe("true")
            }));
            (0, _globals.it)("cards container should render focus decoys", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    }
                }));
                const cardsContainer = container.querySelector(SELECTORS.cardContainer);
                const parentContainer = null === cardsContainer || void 0 === cardsContainer ? void 0 : cardsContainer.parentNode;
                const firstDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.firstElementChild;
                const lastDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.lastElementChild;
                (0, _globals.expect)(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute("tabindex")).toBe("0");
                (0, _globals.expect)(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute("tabindex")).toBe("0")
            }))
        }));
        (0, _globals.describe)("enabled: false", (() => {
            (0, _globals.it)("header items should not contain tabindex", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: false
                    }
                }));
                const headerItem = container.querySelector(SELECTORS.headerItem);
                (0, _globals.expect)(null === headerItem || void 0 === headerItem ? void 0 : headerItem.getAttribute("tabindex")).toBe(null)
            }));
            (0, _globals.it)("header items container should not has active focus decoys", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: false
                    }
                }));
                const headerPanelContent = container.querySelector(SELECTORS.headerPanelContent);
                const parentContainer = null === headerPanelContent || void 0 === headerPanelContent ? void 0 : headerPanelContent.parentElement;
                const firstDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.firstElementChild;
                const lastDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.lastElementChild;
                (0, _globals.expect)(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute("tabindex")).toBe(null);
                (0, _globals.expect)(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute(ATTRS.focusDecoy)).toBe("false");
                (0, _globals.expect)(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute("tabindex")).toBe(null);
                (0, _globals.expect)(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute(ATTRS.focusDecoy)).toBe("false")
            }));
            (0, _globals.it)("cards should not contain tabindex", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: false
                    }
                }));
                const card = container.querySelector(SELECTORS.card);
                (0, _globals.expect)(null === card || void 0 === card ? void 0 : card.getAttribute("tabindex")).toBe(null)
            }));
            (0, _globals.it)("card content should render focus trap container", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: false
                    }
                }));
                const cardContent = container.querySelector(SELECTORS.cardContent);
                const focusTrapNode = null === cardContent || void 0 === cardContent ? void 0 : cardContent.parentElement;
                (0, _globals.expect)(null === focusTrapNode || void 0 === focusTrapNode ? void 0 : focusTrapNode.getAttribute(ATTRS.focusTrapContent)).toBe("false")
            }));
            (0, _globals.it)("card content should not has active focus decoys", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: false
                    }
                }));
                const cardContent = container.querySelector(SELECTORS.cardContent);
                const parentContainer = null === cardContent || void 0 === cardContent ? void 0 : cardContent.parentElement;
                const firstDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.firstElementChild;
                const lastDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.lastElementChild;
                (0, _globals.expect)(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute("tabindex")).toBe(null);
                (0, _globals.expect)(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute(ATTRS.focusDecoy)).toBe("false");
                (0, _globals.expect)(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute("tabindex")).toBe(null);
                (0, _globals.expect)(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute(ATTRS.focusDecoy)).toBe("false")
            }));
            (0, _globals.it)("cards container should not render focus decoys", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: false
                    }
                }));
                const cardsContainer = container.querySelector(SELECTORS.cardContainer);
                const parentContainer = null === cardsContainer || void 0 === cardsContainer ? void 0 : cardsContainer.parentNode;
                const firstDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.firstElementChild;
                const lastDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.lastElementChild;
                (0, _globals.expect)(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute("tabindex")).toBe(null);
                (0, _globals.expect)(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute("tabindex")).toBe(null)
            }))
        }));
        (0, _globals.describe)("onKeyDown", (() => {
            (0, _globals.it)("common API contract test", (() => {
                const callbackMock = _globals.jest.fn();
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    },
                    onKeyDown: callbackMock
                }));
                const headerItem = container.querySelector(SELECTORS.headerItem);
                null === headerItem || void 0 === headerItem || headerItem.dispatchEvent(new KeyboardEvent("keydown", {
                    key: "a",
                    bubbles: true
                }));
                (0, _globals.expect)(callbackMock).toHaveBeenCalledTimes(1);
                const [
                    [{
                        handled: handled,
                        event: event,
                        element: element,
                        component: component
                    }]
                ] = callbackMock.mock.calls;
                (0, _globals.expect)(handled).toBe(false);
                (0, _globals.expect)(event).toStrictEqual(_globals.expect.any(KeyboardEvent));
                (0, _globals.expect)(element).toStrictEqual(_globals.expect.any(HTMLDivElement));
                (0, _globals.expect)(component).toStrictEqual(_globals.expect.any(_widget.default))
            }));
            _globals.it.each(["Escape", " ", "ArrowDown", "ArrowUp", "B"])('should be called with unhandled events on header item: "%s"', (key => {
                const callbackMock = _globals.jest.fn();
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    },
                    onKeyDown: callbackMock
                }));
                const headerItem = container.querySelector(SELECTORS.headerItem);
                null === headerItem || void 0 === headerItem || headerItem.dispatchEvent(new KeyboardEvent("keydown", {
                    key: key,
                    bubbles: true
                }));
                (0, _globals.expect)(callbackMock).toHaveBeenCalledTimes(1);
                const [
                    [{
                        handled: handled,
                        event: {
                            key: eventKey
                        }
                    }]
                ] = callbackMock.mock.calls;
                (0, _globals.expect)(handled).toBe(false);
                (0, _globals.expect)(eventKey).toBe(key)
            }));
            _globals.it.each(["ArrowRight", "ArrowLeft", "Enter"])('should be called with handled events on header item: "%s"', (key => {
                const callbackMock = _globals.jest.fn();
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    },
                    onKeyDown: callbackMock
                }));
                const headerItem = container.querySelector(SELECTORS.headerItem);
                null === headerItem || void 0 === headerItem || headerItem.dispatchEvent(new KeyboardEvent("keydown", {
                    key: key,
                    bubbles: true
                }));
                (0, _globals.expect)(callbackMock).toHaveBeenCalledTimes(1);
                (0, _globals.expect)(callbackMock).toHaveBeenCalledTimes(1);
                const [
                    [{
                        handled: handled,
                        event: {
                            key: eventKey
                        }
                    }]
                ] = callbackMock.mock.calls;
                (0, _globals.expect)(handled).toBe(true);
                (0, _globals.expect)(eventKey).toBe(key)
            }));
            _globals.it.each(["a", " "])('should be called with unhandled events on card: "%s"', (key => {
                const callbackMock = _globals.jest.fn();
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    },
                    onKeyDown: callbackMock
                }));
                const card = container.querySelector(SELECTORS.headerItem);
                null === card || void 0 === card || card.dispatchEvent(new KeyboardEvent("keydown", {
                    key: key,
                    bubbles: true
                }));
                (0, _globals.expect)(callbackMock).toHaveBeenCalledTimes(1);
                const [
                    [{
                        handled: handled,
                        event: {
                            key: eventKey
                        }
                    }]
                ] = callbackMock.mock.calls;
                (0, _globals.expect)(handled).toBe(false);
                (0, _globals.expect)(eventKey).toBe(key)
            }));
            _globals.it.each(["ArrowRight", "ArrowLeft", "Enter"])('should be called with handled events on card: "%s"', (key => {
                const callbackMock = _globals.jest.fn();
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    },
                    onKeyDown: callbackMock
                }));
                const card = container.querySelector(SELECTORS.headerItem);
                null === card || void 0 === card || card.dispatchEvent(new KeyboardEvent("keydown", {
                    key: key,
                    bubbles: true
                }));
                (0, _globals.expect)(callbackMock).toHaveBeenCalledTimes(1);
                const [
                    [{
                        handled: handled,
                        event: {
                            key: eventKey
                        }
                    }]
                ] = callbackMock.mock.calls;
                (0, _globals.expect)(handled).toBe(true);
                (0, _globals.expect)(eventKey).toBe(key)
            }))
        }));
        (0, _globals.describe)("onFocusedCardChanged", (() => {
            (0, _globals.it)("common API contract test", (() => {
                const callbackMock = _globals.jest.fn();
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    },
                    onFocusedCardChanged: callbackMock
                }));
                const cardElement = container.querySelector(SELECTORS.card);
                null === cardElement || void 0 === cardElement || cardElement.dispatchEvent(new KeyboardEvent("keydown", {
                    key: "ArrowRight",
                    bubbles: true
                }));
                (0, _globals.expect)(callbackMock).toHaveBeenCalledTimes(1);
                const [
                    [{
                        cardIndex: cardIndex,
                        card: card,
                        element: element,
                        component: component
                    }]
                ] = callbackMock.mock.calls;
                (0, _globals.expect)(cardIndex).toEqual(1);
                (0, _globals.expect)(card).toMatchSnapshot();
                (0, _globals.expect)(element).toStrictEqual(_globals.expect.any(HTMLDivElement));
                (0, _globals.expect)(component).toStrictEqual(_globals.expect.any(_widget.default))
            }));
            _globals.it.each([{
                idx: 0,
                keys: ["ArrowRight", "ArrowRight"],
                path: [1, 2]
            }, {
                idx: 1,
                keys: ["ArrowRight", "ArrowLeft"],
                path: [1, 0]
            }, {
                idx: 2,
                keys: ["ArrowRight", "ArrowLeft"],
                path: [1, 0]
            }, {
                idx: 3,
                keys: ["ArrowDown", "ArrowRight"],
                path: [3, 4]
            }, {
                idx: 4,
                keys: ["ArrowDown", "ArrowUp"],
                path: [3, 0]
            }, {
                idx: 4,
                keys: ["ArrowDown", "ArrowRight", "ArrowDown", "ArrowLeft"],
                path: [3, 4, 7, 6]
            }, {
                idx: 4,
                keys: ["ArrowRight", "ArrowRight", "ArrowRight", "ArrowRight"],
                path: [1, 2]
            }, {
                idx: 4,
                keys: ["ArrowLeft", "ArrowLeft", "ArrowLeft", "ArrowLeft"],
                path: []
            }, {
                idx: 4,
                keys: ["ArrowDown", "ArrowDown", "ArrowDown", "ArrowDown"],
                path: [3, 6]
            }, {
                idx: 4,
                keys: ["ArrowUp", "ArrowUp", "ArrowUp", "ArrowUp"],
                path: []
            }])("should fire event after each card focus change -> case #$idx", (_ref => {
                let {
                    keys: keys,
                    path: path
                } = _ref;
                const callbackMock = _globals.jest.fn();
                const {
                    container: container
                } = setup({
                    dataSource: new Array(9).fill(null).map(((_, idx) => ({
                        id: idx
                    }))),
                    keyExpr: "id",
                    columns: ["id"],
                    keyboardNavigation: {
                        enabled: true
                    },
                    paging: {
                        pageSize: 9
                    },
                    onFocusedCardChanged: callbackMock
                });
                const cardElement = container.querySelector(SELECTORS.card);
                keys.forEach((key => {
                    null === cardElement || void 0 === cardElement || cardElement.dispatchEvent(new KeyboardEvent("keydown", {
                        key: key,
                        bubbles: true
                    }))
                }));
                const result = callbackMock.mock.calls.flat().map((_ref2 => {
                    let {
                        cardIndex: cardIndex
                    } = _ref2;
                    return cardIndex
                }));
                (0, _globals.expect)(result).toStrictEqual(path)
            }))
        }))
    }))
}));
