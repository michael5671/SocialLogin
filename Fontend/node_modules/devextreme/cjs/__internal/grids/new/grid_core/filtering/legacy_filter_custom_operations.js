/**
 * DevExtreme (cjs/__internal/grids/new/grid_core/filtering/legacy_filter_custom_operations.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.anyOf = anyOf;
exports.noneOf = noneOf;
var _message = _interopRequireDefault(require("../../../../../common/core/localization/message"));
var _data_source = require("../../../../../common/data/data_source/data_source");
var _renderer = _interopRequireDefault(require("../../../../../core/renderer"));
var _deferred = require("../../../../../core/utils/deferred");
var _extend = require("../../../../../core/utils/extend");
var _ui = _interopRequireDefault(require("../../../../../ui/widget/ui.errors"));
var _m_utils = require("../../../../filter_builder/m_utils");
var _legacy_header_filter = require("./header_filter/legacy_header_filter");

function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}

function baseOperation(config) {
    const {
        getHeaderFilterController: getHeaderFilterController
    } = config;
    const getFullText = function(itemText, parentText) {
        return parentText ? `${parentText}/${itemText}` : itemText
    };
    const getSelectedItemsTexts = function(items, parentText) {
        let result = [];
        items.forEach((item => {
            if (item.items) {
                const selectedItemsTexts = getSelectedItemsTexts(item.items, getFullText(item.text, parentText));
                result = result.concat(selectedItemsTexts)
            }
            item.selected && result.push(getFullText(item.text, parentText))
        }));
        return result
    };
    return {
        dataTypes: ["string", "date", "datetime", "number", "boolean", "object"],
        calculateFilterExpression: function(filterValue, field, fields) {
            const result = [];
            const lastIndex = filterValue.length - 1;
            filterValue && filterValue.forEach(((value, index) => {
                if ((0, _m_utils.isCondition)(value) || (0, _m_utils.isGroup)(value)) {
                    const filterExpression = (0, _m_utils.getFilterExpression)(value, fields, [], "headerFilter");
                    result.push(filterExpression)
                } else {
                    const filterExpression = (0, _m_utils.getFilterExpression)([field.dataField ?? field.name, "=", value], fields, [], "headerFilter");
                    result.push(filterExpression)
                }
                index !== lastIndex && result.push("or")
            }));
            if (1 === result.length) {
                return result[0]
            }
            return result
        },
        editorTemplate(conditionInfo, container) {
            const headerFilterController = getHeaderFilterController();
            const div = (0, _renderer.default)("<div>").addClass("dx-filterbuilder-item-value-text").appendTo(container);
            const originalColumn = config.columnOption(conditionInfo.field.dataField);
            const column = (0, _extend.extend)(true, {}, originalColumn);
            (0, _m_utils.renderValueText)(div, conditionInfo.text && conditionInfo.text.split("|"));
            column.filterType = "include";
            column.filterValues = conditionInfo.value ? conditionInfo.value.slice() : [];
            headerFilterController.showHeaderFilterMenuBase({
                columnElement: div,
                column: column,
                customApply(filterValues) {
                    value = filterValues, void conditionInfo.setValue(value);
                    var value;
                    headerFilterController.hideHeaderFilterMenu();
                    conditionInfo.closeEditor()
                },
                onHidden() {
                    conditionInfo.closeEditor()
                },
                isFilterBuilder: true
            });
            return container
        },
        customizeText: function(fieldInfo, options) {
            options = options || {};
            const headerFilterController = getHeaderFilterController();
            const {
                value: value
            } = fieldInfo;
            let column = config.columnOption(fieldInfo.field.dataField);
            const headerFilter = column && column.headerFilter;
            const lookup = column && column.lookup;
            const values = options.values || [value];
            if (headerFilter && headerFilter.dataSource || lookup && lookup.dataSource) {
                const result = new _deferred.Deferred;
                const itemsDeferred = options.items || new _deferred.Deferred;
                if (!options.items) {
                    column = (0, _extend.extend)({}, column, {
                        filterType: "include",
                        filterValues: values
                    });
                    const dataSourceOptions = headerFilterController.getDataSource(column);
                    dataSourceOptions.paginate = false;
                    const dataSource = new _data_source.DataSource(dataSourceOptions);
                    const key = dataSource.store().key();
                    if (key) {
                        const {
                            values: values
                        } = options;
                        if (values && values.length > 1) {
                            const filter = values.reduce(((result, value) => {
                                if (result.length) {
                                    result.push("or")
                                }
                                result.push([key, "=", value]);
                                return result
                            }), []);
                            dataSource.filter(filter)
                        } else {
                            dataSource.filter([key, "=", fieldInfo.value])
                        }
                    } else if (fieldInfo.field.calculateDisplayValue) {
                        _ui.default.log("W1017")
                    }
                    options.items = itemsDeferred;
                    dataSource.load().done(itemsDeferred.resolve)
                }
                itemsDeferred.done((items => {
                    const index = values.indexOf(fieldInfo.value);
                    result.resolve(getSelectedItemsTexts(items, null)[index])
                }));
                return result
            }
            const headerFilterOptions = config.getHeaderFilterOptions();
            const text = (0, _legacy_header_filter.getHeaderItemText)(value, column, 0, headerFilterOptions);
            return text
        }
    }
}

function anyOf(config) {
    return (0, _extend.extend)(baseOperation(config), {
        name: "anyof",
        icon: "selectall",
        caption: _message.default.format("dxFilterBuilder-filterOperationAnyOf")
    })
}

function noneOf(config) {
    const baseOp = baseOperation(config);
    return (0, _extend.extend)({}, baseOp, {
        calculateFilterExpression(filterValue, field, fields) {
            const baseFilter = baseOp.calculateFilterExpression(filterValue, field, fields);
            if (!baseFilter || 0 === baseFilter.length) {
                return null
            }
            return "!" === baseFilter[0] ? baseFilter : ["!", baseFilter]
        },
        name: "noneof",
        icon: "unselectall",
        caption: _message.default.format("dxFilterBuilder-filterOperationNoneOf")
    })
}
