/**
 * DevExtreme (cjs/__internal/grids/new/grid_core/columns_controller/utils.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addDataFieldToComputedColumns = addDataFieldToComputedColumns;
exports.columnOptionUpdate = void 0;
exports.getColumnByIndexOrName = getColumnByIndexOrName;
exports.getColumnFormat = void 0;
exports.getColumnIndexByName = getColumnIndexByName;
exports.getValueDataType = exports.getColumnOptionsFromDataItem = void 0;
exports.getVisibleIndexes = getVisibleIndexes;
exports.normalizeColumn = normalizeColumn;
exports.normalizeColumns = normalizeColumns;
exports.normalizeColumnsVisibleIndexes = normalizeColumnsVisibleIndexes;
exports.normalizeStringColumn = normalizeStringColumn;
exports.normalizeVisibleIndexes = normalizeVisibleIndexes;
exports.preNormalizeColumns = preNormalizeColumns;
var _data = require("../../../../../core/utils/data");
var _inflector = require("../../../../../core/utils/inflector");
var _type = require("../../../../../core/utils/type");
var _index = require("../../../../grids/new/grid_core/utils/tree/index");
var _options = require("./options");

function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) {
                ({}).hasOwnProperty.call(t, r) && (n[r] = t[r])
            }
        }
        return n
    }, _extends.apply(null, arguments)
}

function normalizeColumn(column, templateNormalizationFunc, columnFromDataOptions) {
    const dataType = column.dataType ?? (null === columnFromDataOptions || void 0 === columnFromDataOptions ? void 0 : columnFromDataOptions.dataType) ?? _options.defaultColumnProperties.dataType;
    const columnDataTypeDefaultOptions = _options.defaultColumnPropertiesByDataType[dataType];
    const columnFormat = column.format ?? (null === columnDataTypeDefaultOptions || void 0 === columnDataTypeDefaultOptions ? void 0 : columnDataTypeDefaultOptions.format) ?? (null === columnFromDataOptions || void 0 === columnFromDataOptions ? void 0 : columnFromDataOptions.format);
    const caption = (0, _inflector.captionize)(column.name);
    const colWithDefaults = _extends({}, _options.defaultColumnProperties, columnDataTypeDefaultOptions, {
        caption: caption
    }, column);
    const normalizedColumn = _extends({}, colWithDefaults, {
        dataType: dataType
    }, !!columnFormat && {
        format: columnFormat
    }, {
        calculateDisplayValue: (0, _type.isString)(colWithDefaults.calculateDisplayValue) ? (0, _data.compileGetter)(colWithDefaults.calculateDisplayValue) : colWithDefaults.calculateDisplayValue,
        headerItemTemplate: null === templateNormalizationFunc || void 0 === templateNormalizationFunc ? void 0 : templateNormalizationFunc(colWithDefaults.headerItemTemplate),
        fieldTemplate: null === templateNormalizationFunc || void 0 === templateNormalizationFunc ? void 0 : templateNormalizationFunc(colWithDefaults.fieldTemplate),
        fieldCaptionTemplate: null === templateNormalizationFunc || void 0 === templateNormalizationFunc ? void 0 : templateNormalizationFunc(colWithDefaults.fieldCaptionTemplate),
        fieldValueTemplate: null === templateNormalizationFunc || void 0 === templateNormalizationFunc ? void 0 : templateNormalizationFunc(colWithDefaults.fieldValueTemplate),
        calculateCellValue: colWithDefaults.calculateFieldValue,
        allowFiltering: colWithDefaults.allowFiltering ?? !!colWithDefaults.dataField,
        allowHeaderFiltering: colWithDefaults.allowHeaderFiltering ?? colWithDefaults.allowFiltering ?? !!colWithDefaults.dataField,
        allowSearch: colWithDefaults.allowSearch ?? colWithDefaults.allowFiltering ?? !!colWithDefaults.dataField,
        allowSorting: colWithDefaults.allowSorting ?? !!colWithDefaults.dataField
    });
    normalizedColumn.selector ?? (normalizedColumn.selector = data => normalizedColumn.calculateFieldValue(data));
    return normalizedColumn
}

function getVisibleIndexes(indexes) {
    const newIndexes = [...indexes];
    let minNonExistingIndex = 0;
    indexes.forEach(((visibleIndex, index) => {
        while (newIndexes.includes(minNonExistingIndex)) {
            minNonExistingIndex += 1
        }
        newIndexes[index] = visibleIndex ?? minNonExistingIndex
    }));
    return newIndexes
}

function normalizeVisibleIndexes(indexes, forceIndex) {
    const indexMap = indexes.map(((visibleIndex, index) => [index, visibleIndex]));
    const sortedIndexMap = new Array(indexes.length);
    if ((0, _type.isDefined)(forceIndex)) {
        sortedIndexMap[indexes[forceIndex]] = forceIndex
    }
    let j = 0;
    indexMap.sort(((a, b) => a[1] - b[1])).forEach((_ref => {
        let [index] = _ref;
        if (index === forceIndex) {
            return
        }
        if ((0, _type.isDefined)(sortedIndexMap[j])) {
            j += 1
        }
        sortedIndexMap[j] = index;
        j += 1
    }));
    const returnIndexes = new Array(indexes.length);
    sortedIndexMap.forEach(((index, visibleIndex) => {
        returnIndexes[index] = visibleIndex
    }));
    return returnIndexes
}

function normalizeColumnsVisibleIndexes(columns, forceIndex) {
    const result = [...columns];
    const visibleIndexes = normalizeVisibleIndexes(columns.map((c => c.visibleIndex)), forceIndex);
    visibleIndexes.forEach(((visibleIndex, i) => {
        result[i].visibleIndex = visibleIndex
    }));
    return result
}

function normalizeColumns(columns, templateNormalizationFunc, columnsFromData) {
    return columns.map((col => {
        const columnFromDataOptions = null === columnsFromData || void 0 === columnsFromData ? void 0 : columnsFromData[col.name];
        return normalizeColumn(col, templateNormalizationFunc, columnFromDataOptions)
    }))
}

function preNormalizeColumns(columns) {
    const normalizedColumns = null === columns || void 0 === columns ? void 0 : columns.map((column => {
        if ("string" === typeof column) {
            return {
                dataField: column
            }
        }
        return column
    })).map(((column, index) => _extends({}, column, {
        name: column.name ?? column.dataField ?? `column-${index}`
    })));
    const visibleIndexes = getVisibleIndexes(null === normalizedColumns || void 0 === normalizedColumns ? void 0 : normalizedColumns.map((c => c.visibleIndex)));
    null === normalizedColumns || void 0 === normalizedColumns || normalizedColumns.forEach(((_, i) => {
        normalizedColumns[i].visibleIndex = visibleIndexes[i]
    }));
    return normalizedColumns
}

function normalizeStringColumn(column) {
    if ("string" === typeof column) {
        return {
            dataField: column
        }
    }
    return column
}

function getColumnIndexByName(columns, name) {
    return columns.findIndex((c => c.name === name))
}

function getColumnByIndexOrName(columns, columnNameOrIndex) {
    const column = columns.find(((c, i) => {
        if ((0, _type.isString)(columnNameOrIndex)) {
            return c.name === columnNameOrIndex
        }
        return i === columnNameOrIndex
    }));
    return column
}
const getValueDataType = value => {
    const dataType = (0, _type.type)(value);
    const isUnknownDataType = "string" !== dataType && "boolean" !== dataType && "number" !== dataType && "date" !== dataType && "object" !== dataType;
    return isUnknownDataType ? void 0 : dataType
};
exports.getValueDataType = getValueDataType;
const getColumnFormat = column => {
    if (column.format) {
        return column.format
    }
    if ("date" === column.dataType || "datetime" === column.dataType) {
        return "shortDate"
    }
    return
};
exports.getColumnFormat = getColumnFormat;
const getColumnOptionsFromDataItem = dataItem => {
    const dataFields = Object.keys(dataItem);
    return {
        dataFields: dataFields,
        columns: Object.entries(dataItem).reduce(((result, _ref2) => {
            let [key, value] = _ref2;
            const dataType = getValueDataType(value);
            const format = getColumnFormat({
                dataType: dataType
            });
            result[key] = {
                dataType: dataType,
                format: format
            };
            return result
        }), {})
    }
};
exports.getColumnOptionsFromDataItem = getColumnOptionsFromDataItem;
const columnOptionUpdate = (settings, columnIdx, updatePath, value) => {
    const newSettings = [...settings];
    const updatePathParts = (0, _data.getPathParts)(updatePath);
    const columnTreeNode = (0, _index.getTreeNodeByPath)(newSettings[columnIdx], updatePathParts);
    if (columnTreeNode === value) {
        return settings
    }
    newSettings[columnIdx] = (0, _index.setTreeNodeByPath)(settings[columnIdx], value, updatePathParts);
    return normalizeColumnsVisibleIndexes(newSettings, columnIdx)
};
exports.columnOptionUpdate = columnOptionUpdate;

function addDataFieldToComputedColumns(columns) {
    return columns.map((column => {
        if (column.dataField) {
            return column
        }
        return _extends({}, column, {
            dataField: column.name
        })
    }))
}
