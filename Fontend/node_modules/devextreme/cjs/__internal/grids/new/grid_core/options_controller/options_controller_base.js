/**
 * DevExtreme (cjs/__internal/grids/new/grid_core/options_controller/options_controller_base.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OptionsController = void 0;
var _component = require("../../../../../core/component");
var _data = require("../../../../../core/utils/data");
var _signalsCore = require("@preact/signals-core");
var _m_extend = require("../../../../core/utils/m_extend");
var _template_wrapper = require("../inferno_wrappers/template_wrapper");
var _index = require("../utils/tree/index");

function getOr(cache, key, orElse) {
    if (cache[key]) {
        return cache[key]
    }
    const value = orElse();
    cache[key] = value;
    return value
}
class OptionsController {
    constructor(component) {
        var _component$_getDefaul;
        this.component = component;
        this.cache = {
            oneWay: {},
            oneWayWithChanges: {},
            twoWay: {},
            action: {},
            template: {}
        };
        this.isControlledMode = false;
        this.initialized = this.component.initialized;
        this.defaults = (null === (_component$_getDefaul = component._getDefaultOptions) || void 0 === _component$_getDefaul ? void 0 : _component$_getDefaul.call(component)) ?? {};
        this.internalOptions = (0, _signalsCore.signal)({
            options: (0, _m_extend.extend)(true, {}, component.option()),
            changes: null
        });
        this.updateIsControlledMode();
        component.on("optionChanged", this.onOptionChangedHandler.bind(this))
    }
    updateIsControlledMode() {
        const isControlledMode = this.component.option("integrationOptions.isControlledMode");
        this.isControlledMode = isControlledMode ?? false
    }
    onOptionChangedHandler(optionChanges) {
        const {
            fullName: fullName
        } = optionChanges;
        this.updateIsControlledMode();
        this.updateInternalOptionsState(fullName, optionChanges)
    }
    updateInternalOptionsState(optionFullName) {
        let changes = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        const pathParts = (0, _data.getPathParts)(optionFullName);
        this.internalOptions.value = {
            options: (0, _index.mergeOptionTrees)(this.internalOptions.peek().options, this.component.option(), this.defaults, pathParts),
            changes: changes
        }
    }
    oneWay(name) {
        return getOr(this.cache.oneWay, name, (() => {
            const pathArray = (0, _data.getPathParts)(name);
            return (0, _signalsCore.computed)((() => (0, _index.getTreeNodeByPath)(this.internalOptions.value.options, pathArray)))
        }))
    }
    oneWayWithChanges(name) {
        return getOr(this.cache.oneWayWithChanges, name, (() => {
            const pathArray = (0, _data.getPathParts)(name);
            return (0, _signalsCore.computed)((() => {
                const {
                    options: options,
                    changes: changes
                } = this.internalOptions.value;
                return {
                    value: (0, _index.getTreeNodeByPath)(options, pathArray),
                    changes: changes
                }
            }))
        }))
    }
    twoWay(name) {
        return getOr(this.cache.twoWay, name, (() => {
            const that = this;
            const obs = (0, _signalsCore.signal)(this.component.option(name));
            (0, _signalsCore.effect)((() => {
                obs.value = this.oneWay(name).value
            }));
            return {
                get value() {
                    return obs.value
                },
                set value(value) {
                    const isInitialized = that.initialized.peek();
                    const callbackName = `on${name}Change`;
                    const callback = that.component.option(callbackName);
                    const isControlled = that.isControlledMode && void 0 !== that.component.option(name);
                    if (isControlled) {
                        null === callback || void 0 === callback || callback(value);
                        return
                    }
                    that.component.option(name, value);
                    if (!isInitialized) {
                        that.updateInternalOptionsState(name)
                    }
                    null === callback || void 0 === callback || callback(value)
                },
                peek: () => obs.peek(),
                subscribe() {
                    return obs.subscribe(...arguments)
                },
                toJSON() {
                    return obs.toJSON(...arguments)
                },
                valueOf() {
                    return obs.valueOf(...arguments)
                },
                brand: obs.brand
            }
        }))
    }
    normalizeTemplate(template) {
        return (0, _template_wrapper.TemplateWrapper)(this.component._getTemplate(template))
    }
    template(name) {
        return getOr(this.cache.template, name, (() => {
            const templateOption = this.oneWay(name);
            return (0, _signalsCore.computed)((() => templateOption.value && this.normalizeTemplate(templateOption.value)))
        }))
    }
    action(name) {
        return getOr(this.cache.action, name, (() => {
            const actionOption = this.oneWay(name);
            return (0, _signalsCore.computed)((() => {
                actionOption.value;
                return this.component._createActionByOption(name)
            }))
        }))
    }
}
exports.OptionsController = OptionsController;
OptionsController.dependencies = [_component.Component];
