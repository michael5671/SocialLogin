/**
 * DevExtreme (cjs/__internal/grids/new/grid_core/filtering/header_filter/utils.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.needCreateHeaderFilter = exports.mergeColumnHeaderFilterOptions = exports.isColumnFilterable = exports.getHeaderFilterValuesType = exports.getHeaderFilterInfoArray = exports.getHeaderFilterInfo = exports.getFilterOperator = exports.getComposedHeaderFilter = exports.getColumnName = exports.getColumnIdentifier = void 0;
var _errors = _interopRequireDefault(require("../../../../../../core/errors"));
var _type = require("../../../../../../core/utils/type");
var _filtering = _interopRequireDefault(require("../../../../../../ui/shared/filtering"));
var _m_utils = _interopRequireDefault(require("../../../../../grids/grid_core/m_utils"));
const _excluded = ["texts", "visible"];

function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}

function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) {
                ({}).hasOwnProperty.call(t, r) && (n[r] = t[r])
            }
        }
        return n
    }, _extends.apply(null, arguments)
}

function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) {
        return {}
    }
    var t = {};
    for (var n in r) {
        if ({}.hasOwnProperty.call(r, n)) {
            if (e.includes(n)) {
                continue
            }
            t[n] = r[n]
        }
    }
    return t
}
const mergeColumnHeaderFilterOptions = (column, rootOptions) => {
    var _column$headerFilter;
    const _ref = rootOptions ?? {},
        restRootOptions = _objectWithoutPropertiesLoose(_ref, _excluded);
    return _extends({}, column, {
        allowHeaderFiltering: !!(null !== rootOptions && void 0 !== rootOptions && rootOptions.visible) && !!(null !== column && void 0 !== column && column.allowFiltering) && !!(null !== column && void 0 !== column && column.allowHeaderFiltering),
        headerFilter: _extends({}, restRootOptions, null === column || void 0 === column ? void 0 : column.headerFilter, {
            search: _extends({}, null === restRootOptions || void 0 === restRootOptions ? void 0 : restRootOptions.search, null === column || void 0 === column || null === (_column$headerFilter = column.headerFilter) || void 0 === _column$headerFilter ? void 0 : _column$headerFilter.search)
        })
    })
};
exports.mergeColumnHeaderFilterOptions = mergeColumnHeaderFilterOptions;
const getColumnIdentifier = column => column.name ?? column.dataField;
exports.getColumnIdentifier = getColumnIdentifier;
const getColumnName = column => {
    const name = getColumnIdentifier(column);
    if (!(0, _type.isDefined)(name)) {
        throw _errors.default.Error("E1049", column.caption)
    }
    return name
};
exports.getColumnName = getColumnName;
const getFilterOperator = (values, filterType) => {
    const isInclude = !filterType || "include" === filterType;
    const isValueArray = Array.isArray(values);
    switch (true) {
        case isValueArray && isInclude:
            return "anyof";
        case isValueArray && !isInclude:
            return "noneof";
        case !isValueArray && isInclude:
            return "=";
        case !isValueArray && !isInclude:
            return "<>";
        default:
            throw new Error("Invalid state")
    }
};
exports.getFilterOperator = getFilterOperator;
const isFilteringAllowed = column => column.allowFiltering || column.allowHeaderFiltering;
const isColumnFilterable = column => isFilteringAllowed(column);
exports.isColumnFilterable = isColumnFilterable;
const needCreateHeaderFilter = column => {
    const values = column.filterValues;
    const hasSelectedItems = (0, _type.isDefined)(values) && values.length > 0;
    return isFilteringAllowed(column) && hasSelectedItems
};
exports.needCreateHeaderFilter = needCreateHeaderFilter;
const getFilterExpression = (filterValues, column) => {
    var _column$headerFilter2;
    const columnName = getColumnName(column);
    const hasGroupInterval = !!(null !== (_column$headerFilter2 = column.headerFilter) && void 0 !== _column$headerFilter2 && _column$headerFilter2.groupInterval);
    const needNormalizeFilterValues = 1 === (null === filterValues || void 0 === filterValues ? void 0 : filterValues.length) && !hasGroupInterval;
    const normalizedFilterValues = needNormalizeFilterValues ? filterValues[0] : filterValues;
    const filterOperator = getFilterOperator(normalizedFilterValues, column.filterType);
    return [columnName, filterOperator, normalizedFilterValues]
};
const getHeaderFilterValuesType = column => {
    var _column$headerFilter3;
    const {
        filterValues: filterValues
    } = column;
    if (!(null !== filterValues && void 0 !== filterValues && filterValues.length)) {
        return "empty"
    }
    const [firstFilterItem] = filterValues;
    const hasGroupInterval = !!_filtering.default.getGroupInterval(column);
    const hasCustomDataSource = !!(null !== (_column$headerFilter3 = column.headerFilter) && void 0 !== _column$headerFilter3 && _column$headerFilter3.dataSource);
    const isSingleValue = 1 === filterValues.length && !Array.isArray(firstFilterItem) && (!hasGroupInterval && !hasCustomDataSource || 1 === filterValues.length && null === firstFilterItem);
    return isSingleValue ? "single-value" : "values-or-condition"
};
exports.getHeaderFilterValuesType = getHeaderFilterValuesType;
const getHeaderFilterInfo = column => {
    if (!isFilteringAllowed(column)) {
        return null
    }
    const columnId = getColumnIdentifier(column);
    const headerFilterValueType = getHeaderFilterValuesType(column);
    if ("empty" === headerFilterValueType) {
        return {
            type: "empty",
            columnId: columnId,
            filterType: "include",
            filterValues: [],
            composedFilterValues: []
        }
    }
    const {
        filterType: filterType,
        filterValues: filterValues
    } = column;
    const normalizedFilterType = filterType ?? "include";
    const normalizedFilterValues = Array.isArray(filterValues) ? filterValues : [filterValues];
    const filterValuesWithExpressions = normalizedFilterValues.filter((value => Array.isArray(value)));
    const filterValuesWithoutExpressions = normalizedFilterValues.filter((value => !Array.isArray(value)));
    const filterExpression = filterValuesWithoutExpressions.length ? [getFilterExpression(filterValuesWithoutExpressions, column)] : [];
    const composedFilterValues = _m_utils.default.combineFilters([...filterExpression, ...filterValuesWithExpressions], "or");
    return {
        type: headerFilterValueType,
        columnId: columnId,
        filterType: normalizedFilterType,
        filterValues: filterValues,
        composedFilterValues: composedFilterValues
    }
};
exports.getHeaderFilterInfo = getHeaderFilterInfo;
const getHeaderFilterInfoArray = columns => columns.map((column => getHeaderFilterInfo(column))).filter((info => !!info));
exports.getHeaderFilterInfoArray = getHeaderFilterInfoArray;
const getComposedHeaderFilter = headerFilterInfoArray => headerFilterInfoArray.filter((_ref2 => {
    let {
        type: type
    } = _ref2;
    return "empty" !== type
})).reduce(((result, _ref3, idx, infoArray) => {
    let {
        composedFilterValues: composedFilterValues
    } = _ref3;
    result.push(composedFilterValues);
    if (idx < infoArray.length - 1) {
        result.push("and")
    }
    return result
}), []);
exports.getComposedHeaderFilter = getComposedHeaderFilter;
