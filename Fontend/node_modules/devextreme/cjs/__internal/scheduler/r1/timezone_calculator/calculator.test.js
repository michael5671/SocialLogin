/**
 * DevExtreme (cjs/__internal/scheduler/r1/timezone_calculator/calculator.test.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
var _globals = require("@jest/globals");
var _calculator = require("./calculator");
var _utils = require("./utils");
(0, _globals.describe)("TimeZoneCalculator", (() => {
    (0, _globals.describe)("General tests", (() => {
        const localOffset = 6e4 * (new Date).getTimezoneOffset();
        const sourceDate = new Date(2020, 6, 6, 18, 0);
        const mock = {
            getClientOffset: () => localOffset,
            tryGetCommonOffset: () => 15,
            tryGetAppointmentOffset: () => 7.5
        };
        ["Grid", "Appointment"].forEach((path => {
            (0, _globals.it)(`converting operations with '${path}' should be symmetrical`, (() => {
                const calculator = new _calculator.TimeZoneCalculator(mock);
                const convertedDate = calculator.createDate(sourceDate, `to${path}`);
                const convertedDateBack = calculator.createDate(convertedDate, `from${path}`);
                (0, _globals.expect)(convertedDate.getTime() !== sourceDate.getTime()).toBeTruthy();
                (0, _globals.expect)(sourceDate.getTime() === convertedDateBack.getTime()).toBeTruthy()
            }))
        }));
        [{
            path: "toGrid",
            appointmentTimezone: "America/Los_Angeles",
            timezone: "common"
        }, {
            path: "toGrid",
            appointmentTimezone: void 0,
            timezone: "common"
        }, {
            path: "fromGrid",
            appointmentTimezone: "America/Los_Angeles",
            timezone: "common"
        }, {
            path: "fromGrid",
            appointmentTimezone: void 0,
            timezone: "common"
        }, {
            path: "toAppointment",
            appointmentTimezone: "America/Los_Angeles",
            timezone: "appointment"
        }, {
            path: "toAppointment",
            appointmentTimezone: void 0,
            timezone: "common"
        }, {
            path: "fromAppointment",
            appointmentTimezone: "America/Los_Angeles",
            timezone: "appointment"
        }, {
            path: "fromAppointment",
            appointmentTimezone: void 0,
            timezone: "common"
        }].forEach((_ref => {
            let {
                path: path,
                appointmentTimezone: appointmentTimezone,
                timezone: timezone
            } = _ref;
            (0, _globals.it)(`should use ${timezone} timezone [path: ${path}, appointmentTimezone: ${appointmentTimezone}]`, (() => {
                const calculator = (0, _utils.createTimeZoneCalculator)("America/Los_Angeles");
                const clientMock = _globals.jest.fn().mockReturnValue(0);
                const commonMock = _globals.jest.fn().mockReturnValue(0);
                const appointmentMock = _globals.jest.fn().mockReturnValue(0);
                _globals.jest.spyOn(calculator, "getOffsets").mockImplementation((() => ({
                    get client() {
                        return clientMock()
                    },
                    get common() {
                        return commonMock()
                    },
                    get appointment() {
                        return appointmentMock()
                    }
                })));
                calculator.createDate(sourceDate, path, appointmentTimezone);
                (0, _globals.expect)(clientMock).toHaveBeenCalledTimes(1);
                (0, _globals.expect)(commonMock).toHaveBeenCalledTimes("common" === timezone ? 1 : 0);
                (0, _globals.expect)(appointmentMock).toHaveBeenCalledTimes("appointment" === timezone ? 1 : 0)
            }))
        }));
        (0, _globals.it)("createDate should throw error if wrong path", (() => {
            const calculator = new _calculator.TimeZoneCalculator(mock);
            (0, _globals.expect)((() => {
                calculator.createDate(sourceDate, "WrongPath", "America/Los_Angeles")
            })).toThrow("not specified pathTimeZoneConversion")
        }))
    }));
    (0, _globals.describe)("getOriginStartDateOffsetInMs method", (() => {
        let calculator;
        (0, _globals.beforeEach)((() => {
            calculator = new _calculator.TimeZoneCalculator({
                getClientOffset: () => 252e5,
                tryGetCommonOffset: () => -5,
                tryGetAppointmentOffset: () => 6
            })
        }));
        (0, _globals.it)("should return correct offset for not utc date if appointment timezone set", (() => {
            const testDate = new Date(2021, 1, 1, 10, 0, 0);
            const result = calculator.getOriginStartDateOffsetInMs(testDate, "test", false);
            (0, _globals.expect)(result).toEqual(396e5)
        }));
        (0, _globals.it)("should return correct offset for utc date if appointment timezone set", (() => {
            const testDate = new Date(2021, 1, 1, 10, 0, 0);
            const result = calculator.getOriginStartDateOffsetInMs(testDate, "test", true);
            (0, _globals.expect)(result).toEqual(468e5)
        }));
        (0, _globals.it)("should return correct offset for utc date if appointment timezone not set", (() => {
            const testDate = new Date(2021, 1, 1, 10, 0, 0);
            const result = calculator.getOriginStartDateOffsetInMs(testDate, void 0, true);
            (0, _globals.expect)(result).toEqual(72e5)
        }));
        (0, _globals.it)("should return zero offset for not utc date if appointment timezone not set", (() => {
            const testDate = new Date(2021, 1, 1, 10, 0, 0);
            const result = calculator.getOriginStartDateOffsetInMs(testDate, void 0, false);
            (0, _globals.expect)(result).toEqual(0)
        }))
    }))
}));
