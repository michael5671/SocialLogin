/**
 * DevExtreme (esm/__internal/scheduler/r1/timezone_calculator/calculator.test.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import {
    beforeEach,
    describe,
    expect,
    it,
    jest
} from "@jest/globals";
import {
    TimeZoneCalculator
} from "./calculator";
import {
    createTimeZoneCalculator
} from "./utils";
describe("TimeZoneCalculator", (() => {
    describe("General tests", (() => {
        const localOffset = 6e4 * (new Date).getTimezoneOffset();
        const sourceDate = new Date(2020, 6, 6, 18, 0);
        const mock = {
            getClientOffset: () => localOffset,
            tryGetCommonOffset: () => 15,
            tryGetAppointmentOffset: () => 7.5
        };
        ["Grid", "Appointment"].forEach((path => {
            it(`converting operations with '${path}' should be symmetrical`, (() => {
                const calculator = new TimeZoneCalculator(mock);
                const convertedDate = calculator.createDate(sourceDate, `to${path}`);
                const convertedDateBack = calculator.createDate(convertedDate, `from${path}`);
                expect(convertedDate.getTime() !== sourceDate.getTime()).toBeTruthy();
                expect(sourceDate.getTime() === convertedDateBack.getTime()).toBeTruthy()
            }))
        }));
        [{
            path: "toGrid",
            appointmentTimezone: "America/Los_Angeles",
            timezone: "common"
        }, {
            path: "toGrid",
            appointmentTimezone: void 0,
            timezone: "common"
        }, {
            path: "fromGrid",
            appointmentTimezone: "America/Los_Angeles",
            timezone: "common"
        }, {
            path: "fromGrid",
            appointmentTimezone: void 0,
            timezone: "common"
        }, {
            path: "toAppointment",
            appointmentTimezone: "America/Los_Angeles",
            timezone: "appointment"
        }, {
            path: "toAppointment",
            appointmentTimezone: void 0,
            timezone: "common"
        }, {
            path: "fromAppointment",
            appointmentTimezone: "America/Los_Angeles",
            timezone: "appointment"
        }, {
            path: "fromAppointment",
            appointmentTimezone: void 0,
            timezone: "common"
        }].forEach((_ref => {
            let {
                path: path,
                appointmentTimezone: appointmentTimezone,
                timezone: timezone
            } = _ref;
            it(`should use ${timezone} timezone [path: ${path}, appointmentTimezone: ${appointmentTimezone}]`, (() => {
                const calculator = createTimeZoneCalculator("America/Los_Angeles");
                const clientMock = jest.fn().mockReturnValue(0);
                const commonMock = jest.fn().mockReturnValue(0);
                const appointmentMock = jest.fn().mockReturnValue(0);
                jest.spyOn(calculator, "getOffsets").mockImplementation((() => ({
                    get client() {
                        return clientMock()
                    },
                    get common() {
                        return commonMock()
                    },
                    get appointment() {
                        return appointmentMock()
                    }
                })));
                calculator.createDate(sourceDate, path, appointmentTimezone);
                expect(clientMock).toHaveBeenCalledTimes(1);
                expect(commonMock).toHaveBeenCalledTimes("common" === timezone ? 1 : 0);
                expect(appointmentMock).toHaveBeenCalledTimes("appointment" === timezone ? 1 : 0)
            }))
        }));
        it("createDate should throw error if wrong path", (() => {
            const calculator = new TimeZoneCalculator(mock);
            expect((() => {
                calculator.createDate(sourceDate, "WrongPath", "America/Los_Angeles")
            })).toThrow("not specified pathTimeZoneConversion")
        }))
    }));
    describe("getOriginStartDateOffsetInMs method", (() => {
        let calculator;
        beforeEach((() => {
            calculator = new TimeZoneCalculator({
                getClientOffset: () => 252e5,
                tryGetCommonOffset: () => -5,
                tryGetAppointmentOffset: () => 6
            })
        }));
        it("should return correct offset for not utc date if appointment timezone set", (() => {
            const testDate = new Date(2021, 1, 1, 10, 0, 0);
            const result = calculator.getOriginStartDateOffsetInMs(testDate, "test", false);
            expect(result).toEqual(396e5)
        }));
        it("should return correct offset for utc date if appointment timezone set", (() => {
            const testDate = new Date(2021, 1, 1, 10, 0, 0);
            const result = calculator.getOriginStartDateOffsetInMs(testDate, "test", true);
            expect(result).toEqual(468e5)
        }));
        it("should return correct offset for utc date if appointment timezone not set", (() => {
            const testDate = new Date(2021, 1, 1, 10, 0, 0);
            const result = calculator.getOriginStartDateOffsetInMs(testDate, void 0, true);
            expect(result).toEqual(72e5)
        }));
        it("should return zero offset for not utc date if appointment timezone not set", (() => {
            const testDate = new Date(2021, 1, 1, 10, 0, 0);
            const result = calculator.getOriginStartDateOffsetInMs(testDate, void 0, false);
            expect(result).toEqual(0)
        }))
    }))
}));
