/**
 * DevExtreme (esm/__internal/scheduler/appointments/data_provider/m_appointment_filter_virtual.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import query from "../../../../common/data/query";
import dateUtils from "../../../../core/utils/date";
import {
    dateUtilsTs
} from "../../../core/utils/date";
import {
    isDateAndTimeView,
    isTimelineView
} from "../../../scheduler/r1/utils/index";
import {
    getResourcesByGroupIndex
} from "../../../scheduler/utils/resource_manager/group_utils";
import {
    AppointmentFilterBaseStrategy
} from "./m_appointment_filter";
const toMs = dateUtils.dateToMilliseconds;
export class AppointmentFilterVirtualStrategy extends AppointmentFilterBaseStrategy {
    get resources() {
        return this.options.resources
    }
    filter(preparedItems) {
        const {
            viewOffset: viewOffset
        } = this.options;
        const hourMs = toMs("hour");
        const isCalculateStartAndEndDayHour = isDateAndTimeView(this.viewType);
        const checkIntersectViewport = isCalculateStartAndEndDayHour && "horizontal" === this.viewDirection;
        const isAllDayWorkspace = !this.supportAllDayRow;
        const showAllDayAppointments = this.showAllDayPanel || isAllDayWorkspace;
        const endViewDate = this.viewDataProvider.getLastViewDateByEndDayHour(this.viewEndDayHour);
        const shiftedEndViewDate = dateUtilsTs.addOffsets(endViewDate, [viewOffset]);
        const filterOptions = [];
        const groupsInfo = this.viewDataProvider.getCompletedGroupsInfo();
        groupsInfo.forEach((item => {
            const {
                groupIndex: groupIndex
            } = item;
            const groupStartDate = item.startDate;
            const groupEndDate = new Date(Math.min(item.endDate.getTime(), shiftedEndViewDate.getTime()));
            const startDayHour = isCalculateStartAndEndDayHour ? groupStartDate.getHours() : this.viewStartDayHour;
            const endDayHour = isCalculateStartAndEndDayHour ? startDayHour + groupStartDate.getMinutes() / 60 + (groupEndDate.getTime() - groupStartDate.getTime()) / hourMs : this.viewEndDayHour;
            const resources = this._getPrerenderFilterResources(groupIndex);
            const hasAllDayPanel = this.viewDataProvider.hasGroupAllDayPanel(groupIndex);
            const supportAllDayAppointment = isAllDayWorkspace || !!showAllDayAppointments && hasAllDayPanel;
            filterOptions.push({
                isVirtualScrolling: true,
                startDayHour: startDayHour,
                endDayHour: endDayHour,
                viewOffset: viewOffset,
                viewStartDayHour: this.viewStartDayHour,
                viewEndDayHour: this.viewEndDayHour,
                min: dateUtilsTs.addOffsets(groupStartDate, [-viewOffset]),
                max: dateUtilsTs.addOffsets(groupEndDate, [-viewOffset]),
                supportMultiDayAppointments: isTimelineView(this.viewType),
                allDay: supportAllDayAppointment,
                resources: resources,
                firstDayOfWeek: this.firstDayOfWeek,
                checkIntersectViewport: checkIntersectViewport
            })
        }));
        return this.filterLoadedAppointments({
            filterOptions: filterOptions,
            groupCount: this.groupCount
        }, preparedItems)
    }
    filterPreparedItems(_ref, preparedItems) {
        let {
            filterOptions: filterOptions,
            groupCount: groupCount
        } = _ref;
        const combinedFilters = [];
        let itemsToFilter = preparedItems;
        const needPreFilter = groupCount > 0;
        if (needPreFilter) {
            itemsToFilter = itemsToFilter.filter((_ref2 => {
                let {
                    rawAppointment: rawAppointment
                } = _ref2;
                for (let i = 0; i < filterOptions.length; ++i) {
                    const {
                        resources: resources
                    } = filterOptions[i];
                    if (this._filterAppointmentByResources(rawAppointment, resources)) {
                        return true
                    }
                }
            }))
        }
        filterOptions.forEach((option => {
            combinedFilters.length && combinedFilters.push("or");
            const filter = this._createCombinedFilter(option);
            combinedFilters.push(filter)
        }));
        return query(itemsToFilter).filter(combinedFilters).toArray()
    }
    hasAllDayAppointments(filteredItems, preparedItems) {
        return this.filterAllDayAppointments(preparedItems).length > 0
    }
    _getPrerenderFilterResources(groupIndex) {
        const resourceManager = this.options.getResourceManager();
        return getResourcesByGroupIndex(resourceManager.groupsLeafs, resourceManager.resourceById, groupIndex)
    }
}
AppointmentFilterVirtualStrategy.strategyName = "virtual";
