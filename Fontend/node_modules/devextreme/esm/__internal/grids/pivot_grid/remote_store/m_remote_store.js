/**
 * DevExtreme (esm/__internal/grids/pivot_grid/remote_store/m_remote_store.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import {
    DataSource
} from "../../../../common/data/data_source/data_source";
import {
    normalizeLoadResult
} from "../../../../common/data/data_source/utils";
import Class from "../../../../core/class";
import dateSerialization from "../../../../core/utils/date_serialization";
import {
    Deferred,
    when
} from "../../../../core/utils/deferred";
import {
    extend
} from "../../../../core/utils/extend";
import {
    each
} from "../../../../core/utils/iterator";
import {
    isDefined,
    isString
} from "../../../../core/utils/type";
import {
    capitalize
} from "../../../core/utils/capitalize";
import pivotGridUtils, {
    getExpandedLevel,
    getFiltersByPath,
    setDefaultFieldValueFormatting
} from "../m_widget_utils";
import {
    forEachGroup
} from "./m_remote_store_utils";

function createGroupingOptions(fields, useSortOrder) {
    const groupingOptions = [];
    each(fields, ((index, field) => {
        groupingOptions.push({
            selector: field.dataField,
            groupInterval: field.groupInterval,
            desc: useSortOrder && "desc" === field.sortOrder,
            isExpanded: index < fields.length - 1
        })
    }));
    return groupingOptions
}

function getFieldFilterSelector(field) {
    let selector = field.dataField;
    let {
        groupInterval: groupInterval
    } = field;
    if ("date" === field.dataType && "string" === typeof groupInterval) {
        if ("quarter" === groupInterval.toLowerCase()) {
            groupInterval = "Month"
        }
        selector = `${selector}.${capitalize(groupInterval)}`
    }
    return selector
}

function getIntervalFilterExpression(selector, numericInterval, numericValue, isExcludedFilterType) {
    const startFilterValue = [selector, isExcludedFilterType ? "<" : ">=", numericValue];
    const endFilterValue = [selector, isExcludedFilterType ? ">=" : "<", numericValue + numericInterval];
    return [startFilterValue, isExcludedFilterType ? "or" : "and", endFilterValue]
}

function getFilterExpressionForFilterValue(field, filterValue, filterType) {
    const selector = getFieldFilterSelector(field);
    const isExcludedFilterType = "exclude" === (filterType || field.filterType);
    let expression = [selector, isExcludedFilterType ? "<>" : "=", filterValue];
    if (isDefined(field.groupInterval)) {
        if ("string" === typeof field.groupInterval && "quarter" === field.groupInterval.toLowerCase()) {
            expression = getIntervalFilterExpression(selector, 3, 3 * (filterValue - 1) + 1, isExcludedFilterType)
        } else if ("number" === typeof field.groupInterval && "date" !== field.dataType) {
            expression = getIntervalFilterExpression(selector, field.groupInterval, filterValue, isExcludedFilterType)
        }
    }
    return expression
}

function createFieldFilterExpressions(field, operation) {
    const fieldFilterExpressions = [];
    if (field.searchValue) {
        return [field.dataField, "contains", field.searchValue]
    }
    if ("exclude" === field.filterType) {
        operation = operation || "and"
    } else {
        operation = operation || "or"
    }
    each(field.filterValues, ((index, filterValue) => {
        let currentExpression = [];
        if (Array.isArray(filterValue)) {
            var _field$levels;
            const parseLevelsRecursive = null === (_field$levels = field.levels) || void 0 === _field$levels ? void 0 : _field$levels.length;
            if (parseLevelsRecursive) {
                currentExpression = createFieldFilterExpressions({
                    filterValues: filterValue,
                    filterType: field.filterType,
                    levels: field.levels
                }, "and")
            }
        } else {
            const currentField = field.levels ? field.levels[index] : field;
            currentExpression = getFilterExpressionForFilterValue(currentField, filterValue)
        }
        if (!currentExpression.length) {
            return
        }
        if (fieldFilterExpressions.length) {
            fieldFilterExpressions.push(operation)
        }
        fieldFilterExpressions.push(currentExpression)
    }));
    return fieldFilterExpressions
}

function createFilterExpressions(fields) {
    let filterExpressions = [];
    each(fields, ((_, field) => {
        const fieldExpressions = createFieldFilterExpressions(field);
        if (!fieldExpressions.length) {
            return []
        }
        if (filterExpressions.length) {
            filterExpressions.push("and")
        }
        filterExpressions.push(fieldExpressions);
        return
    }));
    if (1 === filterExpressions.length) {
        filterExpressions = filterExpressions[0]
    }
    return filterExpressions
}

function mergeFilters(filters) {
    let op = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "and";
    const result = [];
    each(filters, ((_, filter) => {
        if ((filter => !!(null !== filter && void 0 !== filter && filter.length))(filter)) {
            result.push(filter, op)
        }
    }));
    result.pop();
    if (1 === result.length) {
        return result[0]
    }
    return result
}

function createLoadOptions(options, externalFilterExpr, hasRows) {
    const loadOptions = {
        groupSummary: [],
        totalSummary: []
    };
    const rowGroupingOptions = createGroupingOptions(options.rows, options.rowTake);
    const columnGroupingOptions = createGroupingOptions(options.columns, options.columnTake);
    const groupingOptions = [...rowGroupingOptions, ...columnGroupingOptions];
    if (groupingOptions.length) {
        loadOptions.group = groupingOptions;
        loadOptions.take = void 0
    } else {
        loadOptions.group = void 0;
        loadOptions.take = 1
    }
    if (options.rows.length && options.rowTake) {
        loadOptions.skip = options.rowSkip;
        loadOptions.take = options.rowTake;
        loadOptions.requireGroupCount = true
    } else if (options.columns.length && options.columnTake && !hasRows) {
        loadOptions.skip = options.columnSkip;
        loadOptions.take = options.columnTake;
        loadOptions.requireGroupCount = true
    }
    let filterExpressions = createFilterExpressions(options.filters);
    filterExpressions = externalFilterExpr ? mergeFilters([filterExpressions, options.filterExpression, externalFilterExpr]) : mergeFilters([filterExpressions, options.filterExpression]);
    if (filterExpressions.length) {
        loadOptions.filter = filterExpressions
    }
    each(options.values, ((_, value) => {
        const summaryOption = {
            selector: value.dataField,
            summaryType: value.summaryType || "count"
        };
        loadOptions.groupSummary.push(summaryOption);
        options.includeTotalSummary && loadOptions.totalSummary.push(summaryOption)
    }));
    return loadOptions
}

function setValue(valuesArray, value, rowIndex, columnIndex, dataIndex) {
    valuesArray[rowIndex] = valuesArray[rowIndex] || [];
    valuesArray[rowIndex][columnIndex] = valuesArray[rowIndex][columnIndex] || [];
    if (!isDefined(valuesArray[rowIndex][columnIndex][dataIndex])) {
        valuesArray[rowIndex][columnIndex][dataIndex] = value
    }
}

function parseValue(value, field) {
    if (field && "number" === field.dataType && isString(value)) {
        return Number(value)
    }
    if (field && "date" === field.dataType && !field.groupInterval && !(value instanceof Date)) {
        return dateSerialization.deserializeDate(value)
    }
    return value
}

function parseResult(data, total, descriptions, result) {
    const rowPath = [];
    let columnPath = [];
    const {
        rowHash: rowHash
    } = result;
    const {
        columnHash: columnHash
    } = result;
    if (null !== total && void 0 !== total && total.summary) {
        each(total.summary, ((index, summary) => {
            setValue(result.values, summary, result.grandTotalRowIndex, result.grandTotalColumnIndex, index)
        }))
    }
    if (total && total.groupCount >= 0) {
        const skip = descriptions.rows.length ? descriptions.rowSkip : descriptions.columnSkip;
        data = [...Array(skip)].concat(data);
        data.length = total.groupCount
    }

    function getItem(dataItem, dimensionName, path, level, field) {
        const dimensionHash = result[`${dimensionName}Hash`];
        let parentItem;
        let parentItemChildren;
        let item;
        const pathValue = path.slice(0, level + 1).join("/");
        let parentPathValue;
        if (void 0 !== dimensionHash[pathValue]) {
            item = dimensionHash[pathValue]
        } else {
            item = {
                value: parseValue(dataItem.key, field),
                index: result[`${dimensionName}Index`]++,
                displayText: dataItem.displayText
            };
            parentPathValue = path.slice(0, level).join("/");
            if (level > 0 && void 0 !== dimensionHash[parentPathValue]) {
                parentItem = dimensionHash[parentPathValue];
                parentItemChildren = parentItem.children = parentItem.children || []
            } else {
                parentItemChildren = result[`${dimensionName}s`]
            }
            parentItemChildren.push(item);
            dimensionHash[pathValue] = item
        }
        return item
    }
    forEachGroup(data, ((item, level) => {
        var _rowItem, _columnItem;
        const rowLevel = level >= descriptions.rows.length ? descriptions.rows.length : level;
        const columnLevel = level >= descriptions.rows.length ? level - descriptions.rows.length : 0;
        let columnItem;
        let rowItem;
        if (level >= descriptions.rows.length && columnLevel >= descriptions.columns.length) {
            return
        }
        if (level < descriptions.rows.length) {
            columnPath = []
        }
        if (level >= descriptions.rows.length) {
            if (item) {
                columnPath[columnLevel] = `${item.key}`;
                columnItem = getItem(item, "column", columnPath, columnLevel, descriptions.columns[columnLevel]);
                rowItem = rowHash[rowPath.slice(0, rowLevel + 1).join("/")]
            } else {
                result.columns.push({})
            }
        } else if (item) {
            rowPath[rowLevel] = `${item.key}`;
            rowItem = getItem(item, "row", rowPath, rowLevel, descriptions.rows[rowLevel]);
            columnItem = columnHash[columnPath.slice(0, columnLevel + 1).join("/")]
        } else {
            result.rows.push({})
        }
        const currentRowIndex = (null === (_rowItem = rowItem) || void 0 === _rowItem ? void 0 : _rowItem.index) || result.grandTotalRowIndex;
        const currentColumnIndex = (null === (_columnItem = columnItem) || void 0 === _columnItem ? void 0 : _columnItem.index) || result.grandTotalColumnIndex;
        each((null === item || void 0 === item ? void 0 : item.summary) || [], ((i, summary) => {
            setValue(result.values, summary, currentRowIndex, currentColumnIndex, i)
        }))
    }));
    return result
}

function getFiltersForDimension(fields) {
    return (null === fields || void 0 === fields ? void 0 : fields.filter((f => {
        var _f$filterValues;
        return (null === (_f$filterValues = f.filterValues) || void 0 === _f$filterValues ? void 0 : _f$filterValues.length) || f.searchValue
    }))) || []
}

function getExpandedIndex(options, axis) {
    if (options.headerName) {
        if (axis === options.headerName) {
            return options.path.length
        }
        if (options.oppositePath) {
            return options.oppositePath.length
        }
    }
    return 0
}

function getFiltersForExpandedDimension(options) {
    const oppositeAxis = "rows" === options.headerName ? "columns" : "rows";
    const fields = options[options.headerName];
    const oppositeFields = options[oppositeAxis];
    const filters = getFiltersByPath(fields, options.path);
    const oppositeFieldsFilters = getFiltersByPath(oppositeFields, options.oppositePath || []);
    return filters.concat(oppositeFieldsFilters)
}

function getFirstCollapsedIndex(fields) {
    for (let index = 0; index < fields.length; index += 1) {
        if (!fields[index].expanded) {
            return index
        }
    }
    return 0
}

function getExpandedPathsFilterExprByLevel(options, axis, level) {
    if (options.headerName === axis) {
        return []
    }
    const firstCollapsedFieldIndex = "rows" === axis ? getFirstCollapsedIndex(options.rows) : getFirstCollapsedIndex(options.columns);
    const startFieldIndex = level <= firstCollapsedFieldIndex ? firstCollapsedFieldIndex : 0;
    const fields = options[axis].slice(startFieldIndex, level);
    const paths = ("rows" === axis ? options.rowExpandedPaths : options.columnExpandedPaths) || [];
    let result = [];
    each(paths, ((_, path) => {
        path = path.slice(startFieldIndex);
        if (!((fields, path) => {
                if (path.length > level) {
                    return false
                }
                let expandedLevel = path.length;
                while (null !== (_fields$expandedLevel = fields[expandedLevel]) && void 0 !== _fields$expandedLevel && _fields$expandedLevel.expanded) {
                    var _fields$expandedLevel;
                    expandedLevel += 1
                }
                return expandedLevel >= level
            })(fields, path)) {
            return
        }
        const filters = [];
        for (let i = 0; i < path.length; i += 1) {
            const field = fields[i];
            if (!isDefined(field)) {
                break
            }
            const fieldFilterExpression = getFilterExpressionForFilterValue(field, path[i], "include");
            filters.push(fieldFilterExpression)
        }
        const pathFilterExpression = mergeFilters(filters);
        result.push(pathFilterExpression)
    }));
    result = mergeFilters(result, "or");
    return result
}

function getGrandTotalRequest(options, dimensionName, commonFilters) {
    const expandedIndex = getExpandedIndex(options, dimensionName);
    const expandedLevel = getExpandedLevel(options, dimensionName);
    const expandedPaths = ("columns" === dimensionName ? options.columnExpandedPaths : options.rowExpandedPaths) || [];
    const oppositeDimensionName = "columns" === dimensionName ? "rows" : "columns";
    const fields = options[dimensionName];
    const result = [];
    if (expandedPaths.length) {
        for (let i = expandedIndex; i <= expandedLevel; i += 1) {
            const slicedFields = fields.slice(expandedIndex, i + 1);
            const filterExpr = getExpandedPathsFilterExprByLevel(options, dimensionName, i);
            const grandTotalOptions = {
                filters: commonFilters,
                filterExpression: filterExpr,
                [dimensionName]: slicedFields,
                [oppositeDimensionName]: []
            };
            result.push(extend({}, options, grandTotalOptions))
        }
    } else {
        const slicedFields = fields.slice(expandedIndex, expandedLevel + 1);
        const grandTotalOptions = {
            filters: commonFilters,
            [dimensionName]: slicedFields,
            [oppositeDimensionName]: []
        };
        result.push(extend({}, options, grandTotalOptions))
    }
    result[0].includeTotalSummary = true;
    return result
}

function createRequestsOptions(options) {
    const rowExpandedIndex = getExpandedIndex(options, "rows");
    const rowExpandedLevel = getExpandedLevel(options, "rows");
    const columnExpandedIndex = getExpandedIndex(options, "columns");
    const columnExpandedLevel = getExpandedLevel(options, "columns");
    const requestsOptions = [];
    const commonFilters = (options.filters || []).concat(getFiltersForDimension(options.rows), getFiltersForDimension(options.columns), getFiltersForExpandedDimension(options));
    const columnTotalsOptions = getGrandTotalRequest(options, "columns", commonFilters);
    const rowTotalsOptions = getGrandTotalRequest(options, "rows", commonFilters);
    if (options.rows.length && options.columns.length) {
        if ("rows" !== options.headerName) {
            requestsOptions.push(...columnTotalsOptions)
        }
        for (let i = rowExpandedIndex; i <= rowExpandedLevel; i += 1) {
            const rows = options.rows.slice(rowExpandedIndex, i + 1);
            const rowsFilterExpr = getExpandedPathsFilterExprByLevel(options, "rows", i);
            for (let j = columnExpandedIndex; j <= columnExpandedLevel; j += 1) {
                const columns = options.columns.slice(columnExpandedIndex, j + 1);
                const columnsFilterExpr = getExpandedPathsFilterExprByLevel(options, "columns", j);
                const filterExpression = mergeFilters([rowsFilterExpr, columnsFilterExpr]);
                const requestOptions = extend({}, options, {
                    columns: columns,
                    rows: rows,
                    filters: commonFilters,
                    filterExpression: filterExpression
                });
                requestsOptions.push(requestOptions)
            }
        }
    } else {
        const totalOptions = options.columns.length ? columnTotalsOptions : rowTotalsOptions;
        requestsOptions.push(...totalOptions)
    }
    return requestsOptions
}

function prepareFields(fields) {
    each(fields || [], ((_, field) => {
        const {
            levels: levels
        } = field;
        if (levels) {
            prepareFields(levels)
        }
        setDefaultFieldValueFormatting(field)
    }))
}
const RemoteStore = Class.inherit({
    ctor(options) {
        this._dataSource = new DataSource(options);
        this._store = this._dataSource.store()
    },
    getFields(fields) {
        const d = new Deferred;
        this._store.load({
            skip: 0,
            take: 20
        }).done((data => {
            const normalizedArguments = normalizeLoadResult(data);
            d.resolve(pivotGridUtils.discoverObjectFields(normalizedArguments.data, fields))
        })).fail(d.reject);
        return d
    },
    key() {
        return this._store.key()
    },
    load(options) {
        const that = this;
        const d = new Deferred;
        const result = {
            rows: [],
            columns: [],
            values: [],
            grandTotalRowIndex: 0,
            grandTotalColumnIndex: 0,
            rowHash: {},
            columnHash: {},
            rowIndex: 1,
            columnIndex: 1
        };
        const requestsOptions = createRequestsOptions(options);
        const deferreds = [];
        prepareFields(options.rows);
        prepareFields(options.columns);
        prepareFields(options.filters);
        each(requestsOptions, ((_, requestOptions) => {
            const loadOptions = createLoadOptions(requestOptions, that.filter(), options.rows.length);
            const loadDeferred = that._store.load(loadOptions);
            deferreds.push(loadDeferred)
        }));
        when.apply(null, deferreds).done((function() {
            const args = deferreds.length > 1 ? arguments : [arguments];
            each(args, ((index, argument) => {
                const normalizedArguments = normalizeLoadResult(argument[0], argument[1]);
                parseResult(normalizedArguments.data, normalizedArguments.extra, requestsOptions[index], result)
            }));
            d.resolve({
                rows: result.rows,
                columns: result.columns,
                values: result.values,
                grandTotalRowIndex: result.grandTotalRowIndex,
                grandTotalColumnIndex: result.grandTotalColumnIndex
            })
        })).fail(d.reject);
        return d
    },
    filter() {
        return this._dataSource.filter.apply(this._dataSource, arguments)
    },
    supportPaging: () => false,
    createDrillDownDataSource(loadOptions, params) {
        loadOptions = loadOptions || {};
        params = params || {};
        const store = this._store;
        const filters = getFiltersByPath(loadOptions.rows, params.rowPath).concat(getFiltersByPath(loadOptions.columns, params.columnPath)).concat(getFiltersForDimension(loadOptions.rows)).concat(loadOptions.filters || []).concat(getFiltersForDimension(loadOptions.columns));
        const filterExp = createFilterExpressions(filters);
        return new DataSource({
            load(loadOptions) {
                const filter = mergeFilters([filterExp, loadOptions.filter]);
                const extendedLoadOptions = extend({}, loadOptions, {
                    filter: 0 === filter.length ? void 0 : filter,
                    select: params.customColumns
                });
                return store.load(extendedLoadOptions)
            }
        })
    }
});
export default {
    RemoteStore: RemoteStore
};
export {
    RemoteStore
};
