/**
 * DevExtreme (esm/__internal/grids/new/card_view/header_panel/column_sortable.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/esm/extends";
const _excluded = ["source", "getColumnByIndex", "allowDragging", "onColumnMove", "columnDragTemplate", "dropFeedbackMode"];
import {
    createVNode,
    createComponentVNode,
    normalizeProps
} from "inferno";
import $ from "../../../../../core/renderer";
import messageLocalization from "../../../../../localization/message";
import {
    combineClasses
} from "../../../../core/utils/combine_classes";
import {
    Component,
    render
} from "inferno";
import {
    Icon
} from "../../grid_core/icon";
import {
    Sortable
} from "../../grid_core/inferno_wrappers/sortable";
const ALLOWED_DRAGGING_DISTANCE = 20;
const CLASS = {
    widget: "dx-widget",
    columnSortable: "dx-cardview-column-sortable",
    dropzone: "dx-cardview-dropzone",
    dropzoneVisible: "dx-cardview-dropzone-visible"
};
export class ColumnSortable extends Component {
    constructor() {
        super(...arguments);
        this.onDragStart = e => {
            var _this$props$isColumnD, _this$props, _this$props$onDragSta, _this$props2;
            const column = this.props.getColumnByIndex(e.fromIndex);
            const isDraggable = (null === (_this$props$isColumnD = (_this$props = this.props).isColumnDraggable) || void 0 === _this$props$isColumnD ? void 0 : _this$props$isColumnD.call(_this$props, column)) ?? true;
            if (!isDraggable) {
                e.cancel = true;
                return
            }
            const {
                source: source
            } = this.props;
            e.itemData = {
                column: column,
                status: "moving",
                source: source,
                destination: source
            };
            e.itemData = _extends({}, e.itemData, this.getNeighborColumns(e));
            null === (_this$props$onDragSta = (_this$props2 = this.props).onDragStart) || void 0 === _this$props$onDragSta || _this$props$onDragSta.call(_this$props2, e)
        };
        this.onDraggableElementShown = e => {
            $(e.dragElement).addClass(CLASS.widget);
            $(e.dragElement).addClass(CLASS.columnSortable)
        };
        this.onDragMove = e => {
            const destination = e.toComponent.option("_source");
            const {
                columnBefore: columnBefore,
                columnAfter: columnAfter
            } = this.getNeighborColumns(e);
            e.itemData.columnBefore = columnBefore;
            e.itemData.columnAfter = columnAfter;
            e.itemData.destination = destination;
            e.itemData.status = this.getDraggingStatus(e);
            this.renderDragTemplate(e.itemData)
        };
        this.onColumnMove = e => {
            var _this$props$onColumnM, _this$props3;
            if ("forbid" === e.itemData.status) {
                return
            }
            null === (_this$props$onColumnM = (_this$props3 = this.props).onColumnMove) || void 0 === _this$props$onColumnM || _this$props$onColumnM.call(_this$props3, e.itemData.column, e.toIndex, e.itemData)
        };
        this.renderDragTemplate = itemData => {
            if (!itemData || !this.dragItemContainer) {
                return
            }
            const DragTemplate = this.props.columnDragTemplate;
            render(createComponentVNode(2, DragTemplate, {
                column: itemData.column,
                status: itemData.status,
                isDragging: true
            }), this.dragItemContainer)
        }
    }
    render() {
        const _this$props4 = this.props,
            {
                source: source,
                allowDragging: allowDragging,
                columnDragTemplate: columnDragTemplate,
                dropFeedbackMode: dropFeedbackMode
            } = _this$props4,
            restProps = _objectWithoutPropertiesLoose(_this$props4, _excluded);
        const needSortable = allowDragging ?? true;
        if (!needSortable) {
            return this.props.children
        }
        const dragTemplate = columnDragTemplate ? (e, container) => {
            this.dragItemContainer = $(container).get(0);
            this.renderDragTemplate(e.itemData)
        } : void 0;
        const dropzoneClasses = combineClasses({
            [CLASS.dropzone]: true,
            [CLASS.dropzoneVisible]: !!this.props.showDropzone
        });
        return normalizeProps(createComponentVNode(2, Sortable, _extends({
            boundary: "body"
        }, restProps, {
            dropFeedbackMode: dropFeedbackMode ?? "indicate",
            onDragStart: this.onDragStart,
            group: "dx-cardview-columns",
            onAdd: this.onColumnMove,
            onReorder: this.onColumnMove,
            onDragMove: this.onDragMove,
            dragTemplate: dragTemplate,
            _source: source,
            onPlaceholderPrepared: this.props.onPlaceholderPrepared,
            onDraggableElementShown: this.onDraggableElementShown,
            children: [this.props.children, createVNode(1, "div", dropzoneClasses, [createComponentVNode(2, Icon, {
                name: "dropzone"
            }), createVNode(1, "span", null, messageLocalization.format("dxCardView-headerItemDropZoneText"), 0)], 4)]
        })))
    }
    getDraggingStatus(e) {
        const {
            column: column,
            source: source,
            destination: destination,
            columnBefore: columnBefore,
            columnAfter: columnAfter
        } = e.itemData;
        const containerRect = $(e.element).get(0).getBoundingClientRect();
        const mouseX = e.event.clientX;
        const mouseY = e.event.clientY;
        const yDistance = Math.min(Math.abs(mouseY - containerRect.y), Math.abs(mouseY - (containerRect.y + containerRect.height)));
        const isMouseOnSourceContainer = mouseX >= containerRect.x && mouseX <= containerRect.x + containerRect.width && mouseY >= containerRect.y && mouseY <= containerRect.y + containerRect.height;
        if ("column-chooser" === source && "header-panel-main" === destination) {
            return "moving"
        }
        if ("header-panel-main" === source && "column-chooser" === destination) {
            return column.allowHiding ? "moving" : "forbid"
        }
        if ("header-panel-main" === source && "header-panel-main" === destination) {
            const isDragCloseEnough = yDistance <= 20;
            const canReorder = column.allowReordering;
            const canInsert = !!(null !== columnBefore && void 0 !== columnBefore && columnBefore.allowReordering) || !!(null !== columnAfter && void 0 !== columnAfter && columnAfter.allowReordering);
            const isMoving = isDragCloseEnough && canInsert && canReorder;
            return isMoving ? "moving" : "forbid"
        }
        if ("column-chooser" === source && "column-chooser" === destination) {
            const isMoving = isMouseOnSourceContainer;
            return isMoving ? "moving" : "forbid"
        }
        return "forbid"
    }
    getNeighborColumns(e) {
        const {
            source: source,
            destination: destination
        } = e.itemData;
        if ("header-panel-main" !== destination) {
            return {
                columnBefore: void 0,
                columnAfter: void 0
            }
        }
        const column = e.itemData.column;
        const toIndex = e.toIndex ?? column.headerPanelIndex;
        const {
            visibleColumns: visibleColumns
        } = this.props;
        if ("header-panel-main" === source) {
            const isMovingLeft = toIndex < column.headerPanelIndex;
            return isMovingLeft ? {
                columnBefore: visibleColumns[toIndex - 1],
                columnAfter: visibleColumns[toIndex]
            } : {
                columnBefore: visibleColumns[toIndex],
                columnAfter: visibleColumns[toIndex + 1]
            }
        }
        if ("column-chooser" === source) {
            return {
                columnBefore: visibleColumns[toIndex - 1],
                columnAfter: visibleColumns[toIndex]
            }
        }
        return {
            columnBefore: void 0,
            columnAfter: void 0
        }
    }
}
