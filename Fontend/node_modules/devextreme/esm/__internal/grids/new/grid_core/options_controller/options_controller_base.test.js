/**
 * DevExtreme (esm/__internal/grids/new/grid_core/options_controller/options_controller_base.test.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import {
    beforeEach,
    describe,
    expect,
    it,
    jest
} from "@jest/globals";
import {
    createComponentMock
} from "./component.mock";
import {
    OptionsController
} from "./options_controller_base";
const setup = (options, defaultOptions) => {
    const onOptionChangedMock = jest.fn();
    const component = createComponentMock(options, defaultOptions);
    const optionsController = new OptionsController(component);
    return {
        component: component,
        optionsController: optionsController,
        onOptionChangedMock: onOptionChangedMock
    }
};
describe("oneWay", (() => {
    const plainOptions = {
        value: "ABC"
    };
    const defaultPlainOptions = {
        value: "default_ABC"
    };
    const nestedPlainOptions = {
        nested: {
            value: "ABC"
        }
    };
    const defaultNestedPlainOptions = {
        nested: {
            value: "default_ABC"
        }
    };
    const arrayOptions = {
        value: ["A", "B", "C"]
    };
    const defaultArrayOptions = {
        value: ["A_default", "B_default"]
    };
    const functionOptions = {
        value: function() {}
    };
    const defaultFunctionOptions = {
        value: function() {}
    };
    const mixedPlainOptions = {
        value: "default"
    };
    const mixedComplexOptions = {
        value: {
            valueA: "A",
            valueB: "B"
        }
    };
    describe("initial values", (() => {
        describe("plain options", (() => {
            it("should have initial value same as passed in config", (() => {
                const {
                    optionsController: optionsController
                } = setup(plainOptions, defaultPlainOptions);
                const value = optionsController.oneWay("value");
                expect(value.peek()).toBe(plainOptions.value)
            }));
            it("should have initial default value if config options is undefined", (() => {
                const {
                    optionsController: optionsController
                } = setup({}, defaultPlainOptions);
                const value = optionsController.oneWay("value");
                expect(value.peek()).toBe(defaultPlainOptions.value)
            }));
            it("should have initial value same as passed in config if default not specified", (() => {
                const optionalOptions = {
                    optionalValue: "ABC"
                };
                const {
                    optionsController: optionsController
                } = setup(optionalOptions, defaultPlainOptions);
                const value = optionsController.oneWay("optionalValue");
                expect(value.peek()).toBe(optionalOptions.optionalValue)
            }));
            it("should have undefined value if options not passed with config and doesnt have default value", (() => {
                const {
                    optionsController: optionsController
                } = setup(plainOptions, defaultPlainOptions);
                const value = optionsController.oneWay("optionalValue");
                expect(value.peek()).toBe(void 0)
            }))
        }));
        describe("object options child subscription", (() => {
            it("should have initial value same as passed in config", (() => {
                const {
                    optionsController: optionsController
                } = setup(nestedPlainOptions, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested.value");
                expect(value.peek()).toBe(nestedPlainOptions.nested.value)
            }));
            it("should have initial default value if parent config option is undefined", (() => {
                var _defaultNestedPlainOp;
                const {
                    optionsController: optionsController
                } = setup({}, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested.value");
                expect(value.peek()).toBe(null === (_defaultNestedPlainOp = defaultNestedPlainOptions.nested) || void 0 === _defaultNestedPlainOp ? void 0 : _defaultNestedPlainOp.value)
            }));
            it("should have initial default value if plain config option is undefined", (() => {
                var _defaultNestedPlainOp2;
                const {
                    optionsController: optionsController
                } = setup({
                    nested: {
                        value: void 0
                    }
                }, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested.value");
                expect(value.peek()).toBe(null === (_defaultNestedPlainOp2 = defaultNestedPlainOptions.nested) || void 0 === _defaultNestedPlainOp2 ? void 0 : _defaultNestedPlainOp2.value)
            }));
            it("should have initial value same as passed in config if default not specified", (() => {
                var _defaultNestedPlainOp3;
                const {
                    optionsController: optionsController
                } = setup({
                    nested: {
                        optionalValue: "ABC"
                    }
                }, defaultNestedPlainOptions);
                const value = optionsController.oneWay("optionalValue");
                expect(value.peek()).toBe(null === (_defaultNestedPlainOp3 = defaultNestedPlainOptions.nested) || void 0 === _defaultNestedPlainOp3 ? void 0 : _defaultNestedPlainOp3.optionalValue)
            }));
            it("should have undefined value if options not passed with config and doesnt have default value", (() => {
                const {
                    optionsController: optionsController
                } = setup(nestedPlainOptions, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested.optionalValue");
                expect(value.peek()).toBe(void 0)
            }))
        }));
        describe("object options self subscription", (() => {
            it("should have initial value same as passed in config", (() => {
                const {
                    optionsController: optionsController
                } = setup(nestedPlainOptions, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested");
                expect(value.peek()).toStrictEqual(nestedPlainOptions.nested)
            }));
            it("should have initial default value if config options is undefined", (() => {
                const {
                    optionsController: optionsController
                } = setup({}, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested");
                expect(value.peek()).toStrictEqual(defaultNestedPlainOptions.nested)
            }));
            it("should have initial default value if child config option is undefined", (() => {
                const {
                    optionsController: optionsController
                } = setup({
                    nested: {
                        value: void 0
                    }
                }, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested");
                expect(value.peek()).toStrictEqual(defaultNestedPlainOptions.nested)
            }));
            it("should merge passed optional values with default ones", (() => {
                const optionalOptions = {
                    nested: {
                        optionalValue: "ABC"
                    }
                };
                const {
                    optionsController: optionsController
                } = setup(optionalOptions, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested");
                expect(value.peek()).toStrictEqual(_extends({}, defaultNestedPlainOptions.nested, optionalOptions.nested))
            }))
        }));
        describe("array options", (() => {
            it("should have initial value same as passed in config", (() => {
                const {
                    optionsController: optionsController
                } = setup(arrayOptions, defaultArrayOptions);
                const value = optionsController.oneWay("value");
                expect(value.peek()).toStrictEqual(arrayOptions.value)
            }));
            it("should have initial default value if config options is undefined", (() => {
                const {
                    optionsController: optionsController
                } = setup({}, defaultArrayOptions);
                const value = optionsController.oneWay("value");
                expect(value.peek()).toStrictEqual(defaultArrayOptions.value)
            }));
            it("should have initial value same as passed in config if default not specified", (() => {
                const optionalOptions = {
                    optionalValue: ["A_optional", "B_optional"]
                };
                const {
                    optionsController: optionsController
                } = setup(optionalOptions, defaultArrayOptions);
                const value = optionsController.oneWay("optionalValue");
                expect(value.peek()).toStrictEqual(optionalOptions.optionalValue)
            }));
            it("should have undefined value if options not passed with config and doesnt have default value", (() => {
                const {
                    optionsController: optionsController
                } = setup(arrayOptions, defaultArrayOptions);
                const value = optionsController.oneWay("optionalValue");
                expect(value.peek()).toBe(void 0)
            }))
        }));
        describe("function options", (() => {
            it("should have initial value same as passed in config", (() => {
                var _value$peek, _functionOptions$valu;
                const {
                    optionsController: optionsController
                } = setup(functionOptions, defaultFunctionOptions);
                const value = optionsController.oneWay("value");
                expect(null === (_value$peek = value.peek()) || void 0 === _value$peek ? void 0 : _value$peek.name).toBe(null === (_functionOptions$valu = functionOptions.value) || void 0 === _functionOptions$valu ? void 0 : _functionOptions$valu.name)
            }));
            it("should have initial default value if config options is undefined", (() => {
                var _value$peek2, _defaultFunctionOptio;
                const {
                    optionsController: optionsController
                } = setup({}, defaultFunctionOptions);
                const value = optionsController.oneWay("value");
                expect(null === (_value$peek2 = value.peek()) || void 0 === _value$peek2 ? void 0 : _value$peek2.name).toBe(null === (_defaultFunctionOptio = defaultFunctionOptions.value) || void 0 === _defaultFunctionOptio ? void 0 : _defaultFunctionOptio.name)
            }));
            it("should have initial value same as passed in config if default not specified", (() => {
                var _value$peek3;
                const {
                    optionsController: optionsController
                } = setup({
                    optionalValue: function() {}
                }, defaultFunctionOptions);
                const value = optionsController.oneWay("optionalValue");
                expect(null === (_value$peek3 = value.peek()) || void 0 === _value$peek3 ? void 0 : _value$peek3.name).toBe("optionalFnValue")
            }));
            it("should have undefined value if options not passed with config and doesnt have default value", (() => {
                const {
                    optionsController: optionsController
                } = setup(functionOptions, defaultFunctionOptions);
                const value = optionsController.oneWay("optionalValue");
                expect(value.peek()).toBe(void 0)
            }))
        }));
        describe("mixed options child subscription", (() => {
            it("should have initial value same as passed in config", (() => {
                const {
                    optionsController: optionsController
                } = setup(mixedComplexOptions, mixedPlainOptions);
                const value = optionsController.oneWay("value.valueA");
                expect(value.peek()).toStrictEqual(mixedComplexOptions.value.valueA)
            }));
            it("should have initial value undefined if parent is plain value", (() => {
                const {
                    optionsController: optionsController
                } = setup(mixedPlainOptions, mixedComplexOptions);
                const value = optionsController.oneWay("value.valueA");
                expect(value.peek()).toBe(void 0)
            }));
            it("should have initial default value if config options is undefined", (() => {
                const {
                    optionsController: optionsController
                } = setup({}, mixedComplexOptions);
                const value = optionsController.oneWay("value.valueA");
                expect(value.peek()).toBe(mixedComplexOptions.value.valueA)
            }))
        }));
        describe("mixed options self subscription", (() => {
            it("should have initial value same as passed in config", (() => {
                const {
                    optionsController: optionsController
                } = setup(mixedComplexOptions, mixedPlainOptions);
                const value = optionsController.oneWay("value");
                expect(value.peek()).toStrictEqual(mixedComplexOptions.value)
            }));
            it("should have initial default value if config options is undefined", (() => {
                const {
                    optionsController: optionsController
                } = setup({}, mixedPlainOptions);
                const value = optionsController.oneWay("value");
                expect(value.peek()).toBe(mixedPlainOptions.value)
            }))
        }))
    }));
    describe("update values", (() => {
        describe("plain options", (() => {
            it("should update on option changed", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(plainOptions, defaultPlainOptions);
                const value = optionsController.oneWay("value");
                component.option("value", "newValue");
                expect(value.peek()).toBe("newValue")
            }));
            it("should update boolean plain option on option changed", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup({}, {
                    value: true
                });
                const value = optionsController.oneWay("value");
                component.option("value", false);
                expect(value.peek()).toBe(false)
            }));
            it("should update to default value if updated to undefined", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(plainOptions, defaultPlainOptions);
                const value = optionsController.oneWay("value");
                component.option("value", void 0);
                expect(value.peek()).toBe(defaultPlainOptions.value)
            }));
            it("should update initial undefined value to updated value", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(plainOptions, defaultPlainOptions);
                const value = optionsController.oneWay("optionalValue");
                component.option("optionalValue", "newValue");
                expect(value.peek()).toBe("newValue")
            }))
        }));
        describe("object options child subscription", (() => {
            it("should update on option changed", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(nestedPlainOptions, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested.value");
                component.option("nested.value", "newValue");
                expect(value.peek()).toBe("newValue")
            }));
            it("should update on parent option changed", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(nestedPlainOptions, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested.value");
                component.option("nested", {
                    value: "newValue"
                });
                expect(value.peek()).toBe("newValue")
            }));
            it("should update to default value if updated to undefined", (() => {
                var _defaultNestedPlainOp4;
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(nestedPlainOptions, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested.value");
                component.option("nested.value", void 0);
                expect(value.peek()).toBe(null === (_defaultNestedPlainOp4 = defaultNestedPlainOptions.nested) || void 0 === _defaultNestedPlainOp4 ? void 0 : _defaultNestedPlainOp4.value)
            }));
            it("should update to default value if parent option updated to undefined", (() => {
                var _defaultNestedPlainOp5;
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(nestedPlainOptions, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested.value");
                component.option("nested", void 0);
                expect(value.peek()).toBe(null === (_defaultNestedPlainOp5 = defaultNestedPlainOptions.nested) || void 0 === _defaultNestedPlainOp5 ? void 0 : _defaultNestedPlainOp5.value)
            }));
            it("should update initial undefined value to updated value", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(nestedPlainOptions, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested.optionalValue");
                component.option("nested.optionalValue", "newValue");
                expect(value.peek()).toBe("newValue")
            }));
            it("should update initial undefined value to updated value on parent option update", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(nestedPlainOptions, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested.optionalValue");
                component.option("nested", {
                    optionalValue: "newValue"
                });
                expect(value.peek()).toBe("newValue")
            }))
        }));
        describe("object options self subscription", (() => {
            it("should update on option changed", (() => {
                const updatedOptions = {
                    value: "newValue",
                    optionalValue: "newValue_2"
                };
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(nestedPlainOptions, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested");
                component.option("nested", updatedOptions);
                expect(value.peek()).toStrictEqual(updatedOptions)
            }));
            it("should update on child option changed", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(nestedPlainOptions, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested");
                component.option("nested.value", "newValue");
                expect(value.peek()).toStrictEqual({
                    value: "newValue"
                })
            }));
            it("should update to default value if updated to undefined", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(nestedPlainOptions, defaultNestedPlainOptions);
                const value = optionsController.oneWay("nested");
                component.option("nested", void 0);
                expect(value.peek()).toStrictEqual(defaultNestedPlainOptions.nested)
            }))
        }));
        describe("array options", (() => {
            it("should update on whole array option changed", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(arrayOptions, defaultArrayOptions);
                const value = optionsController.oneWay("value");
                component.option("value", ["F", "E"]);
                expect(value.peek()).toStrictEqual(["F", "E"])
            }));
            it("should update on array element option changed", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(arrayOptions, defaultArrayOptions);
                const value = optionsController.oneWay("value");
                component.option("value[0]", "F");
                expect(value.peek()).toStrictEqual(["F", "B", "C"])
            }));
            it("should update on array element child option changed", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup({
                    value: [{
                        A: "A_0",
                        B: "B_0"
                    }, {
                        A: "A_1",
                        B: "B_1"
                    }]
                }, {});
                const value = optionsController.oneWay("value");
                component.option("value[0].A", "F");
                expect(value.peek()).toStrictEqual([{
                    A: "F",
                    B: "B_0"
                }, {
                    A: "A_1",
                    B: "B_1"
                }])
            }));
            it("should update to default value if updated to undefined", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(arrayOptions, defaultArrayOptions);
                const value = optionsController.oneWay("value");
                component.option("value", void 0);
                expect(value.peek()).toStrictEqual(defaultArrayOptions.value)
            }));
            it("should update initial undefined value to updated value", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(arrayOptions, defaultArrayOptions);
                const value = optionsController.oneWay("optionalValue");
                component.option("optionalValue", ["F", "E"]);
                expect(value.peek()).toStrictEqual(["F", "E"])
            }))
        }));
        describe("function options", (() => {
            it("should update on option changed", (() => {
                var _value$peek4;
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(functionOptions, defaultFunctionOptions);
                const value = optionsController.oneWay("value");
                component.option("value", (function() {}));
                expect(null === (_value$peek4 = value.peek()) || void 0 === _value$peek4 ? void 0 : _value$peek4.name).toBe("newFn")
            }));
            it("should update to default value if updated to undefined", (() => {
                var _value$peek5, _defaultFunctionOptio2;
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(functionOptions, defaultFunctionOptions);
                const value = optionsController.oneWay("value");
                component.option("value", void 0);
                expect(null === (_value$peek5 = value.peek()) || void 0 === _value$peek5 ? void 0 : _value$peek5.name).toBe(null === (_defaultFunctionOptio2 = defaultFunctionOptions.value) || void 0 === _defaultFunctionOptio2 ? void 0 : _defaultFunctionOptio2.name)
            }));
            it("should update initial undefined value to updated value", (() => {
                var _value$peek6;
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(functionOptions, defaultFunctionOptions);
                const value = optionsController.oneWay("optionalValue");
                component.option("optionalValue", (function() {}));
                expect(null === (_value$peek6 = value.peek()) || void 0 === _value$peek6 ? void 0 : _value$peek6.name).toBe("newFn")
            }))
        }));
        describe("mixed options child subscription", (() => {
            it("should update on option changed", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(mixedComplexOptions, mixedPlainOptions);
                const value = optionsController.oneWay("value.valueA");
                component.option("value.valueA", "newValue");
                expect(value.peek()).toBe("newValue")
            }));
            it("should update to default value if updated to undefined", (() => {
                var _mixedComplexOptions$;
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(mixedComplexOptions, mixedComplexOptions);
                const value = optionsController.oneWay("value.valueA");
                component.option("value.valueA", void 0);
                expect(value.peek()).toBe(null === (_mixedComplexOptions$ = mixedComplexOptions.value) || void 0 === _mixedComplexOptions$ ? void 0 : _mixedComplexOptions$.valueA)
            }));
            it("should update to undefined if parent option update to plain one", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(mixedComplexOptions, mixedPlainOptions);
                const value = optionsController.oneWay("value.valueA");
                component.option("value", "plain");
                expect(value.peek()).toBe(void 0)
            }));
            it("should update to default value if parent updated to undefined", (() => {
                var _mixedComplexOptions$2;
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(mixedComplexOptions, mixedComplexOptions);
                const value = optionsController.oneWay("value.valueA");
                component.option("value", void 0);
                expect(value.peek()).toBe(null === (_mixedComplexOptions$2 = mixedComplexOptions.value) || void 0 === _mixedComplexOptions$2 ? void 0 : _mixedComplexOptions$2.valueA)
            }));
            it("should update to undefined if default value is plain", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(mixedComplexOptions, mixedPlainOptions);
                const value = optionsController.oneWay("value.valueA");
                component.option("value", void 0);
                expect(value.peek()).toBe(void 0)
            }))
        }));
        describe("mixed options self subscription", (() => {
            it("should update on option changed", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(mixedComplexOptions, mixedPlainOptions);
                const value = optionsController.oneWay("value");
                component.option("value", {
                    valueA: "1",
                    valueB: "2"
                });
                expect(value.peek()).toStrictEqual({
                    valueA: "1",
                    valueB: "2"
                })
            }));
            it("should update on option changed to plain", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(mixedComplexOptions, mixedPlainOptions);
                const value = optionsController.oneWay("value");
                component.option("value", "newValue");
                expect(value.peek()).toBe("newValue")
            }));
            it("should update on child option changed", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(mixedComplexOptions, mixedComplexOptions);
                const value = optionsController.oneWay("value");
                component.option("value.valueA", "newValue");
                expect(value.peek()).toStrictEqual({
                    valueA: "newValue",
                    valueB: "B"
                })
            }));
            it("should update to default value if updated to undefined", (() => {
                const {
                    component: component,
                    optionsController: optionsController
                } = setup(mixedComplexOptions, mixedPlainOptions);
                const value = optionsController.oneWay("value");
                component.option("value", void 0);
                expect(value.peek()).toStrictEqual(mixedPlainOptions.value)
            }))
        }))
    }))
}));
describe("twoWay", (() => {
    const onOptionChangedTestMock = jest.fn();
    const testOptions = {
        value: "initialValue",
        objectValue: {
            nestedValue: "initialNestedValue"
        },
        onOptionChanged: onOptionChangedTestMock
    };
    const defaultTestOptions = {
        value: "value_default",
        objectValue: {
            nestedValue: "nestedValue_default"
        }
    };
    beforeEach((() => {
        onOptionChangedTestMock.mockClear()
    }));
    it("should have initial value", (() => {
        const {
            optionsController: optionsController
        } = setup(testOptions, defaultTestOptions);
        const value = optionsController.twoWay("value");
        expect(value.value).toBe("initialValue")
    }));
    it("should update on options changed", (() => {
        const {
            component: component,
            optionsController: optionsController
        } = setup(testOptions, defaultTestOptions);
        const value = optionsController.twoWay("value");
        const fn = jest.fn();
        value.subscribe(fn);
        component.option("value", "newValue");
        expect(fn).toHaveBeenCalledTimes(2);
        expect(fn).toHaveBeenCalledWith("newValue")
    }));
    it("should return new value after update", (() => {
        const {
            optionsController: optionsController
        } = setup(testOptions, defaultTestOptions);
        const value = optionsController.twoWay("value");
        value.value = "newValue";
        expect(value.value).toBe("newValue")
    }));
    it("should call optionChanged on update", (() => {
        const {
            component: component,
            optionsController: optionsController
        } = setup(testOptions, defaultTestOptions);
        const value = optionsController.twoWay("value");
        value.value = "newValue";
        expect(testOptions.onOptionChanged).toHaveBeenCalledTimes(1);
        expect(testOptions.onOptionChanged).toHaveBeenCalledWith({
            component: component,
            fullName: "value",
            name: "value",
            previousValue: "initialValue",
            value: "newValue"
        })
    }))
}));
describe("oneWayWithChanges", (() => {
    it("should return changes: null if optionChanged was not called", (() => {
        const publicOptions = {
            value: {
                str: "str"
            }
        };
        const {
            optionsController: optionsController
        } = setup(publicOptions, {});
        const value = optionsController.oneWayWithChanges("value");
        expect(value.peek()).toStrictEqual({
            changes: null,
            value: publicOptions.value
        })
    }));
    it("should return changes if optionChanged was called", (() => {
        const {
            component: component,
            optionsController: optionsController
        } = setup({
            value: "str"
        }, {});
        component.option("value", "str_2");
        const value = optionsController.oneWayWithChanges("value");
        const result = value.peek();
        expect(result.changes).toMatchObject({
            name: "value",
            fullName: "value",
            value: "str_2",
            previousValue: "str"
        });
        expect(result.value).toStrictEqual("str_2")
    }));
    it("should return changes of nested option if optionChanged was called", (() => {
        const {
            component: component,
            optionsController: optionsController
        } = setup({
            a: {
                b: {
                    c: "C_0"
                }
            }
        }, {});
        component.option("a.b.c", "C_1");
        const value = optionsController.oneWayWithChanges("a.b.c");
        const result = value.peek();
        expect(result.changes).toMatchObject({
            name: "a",
            fullName: "a.b.c",
            value: "C_1",
            previousValue: "C_0"
        });
        expect(result.value).toStrictEqual("C_1")
    }));
    it("should use different cache with oneWay", (() => {
        const {
            optionsController: optionsController
        } = setup({
            value: "123"
        }, {});
        const value = optionsController.oneWay("value");
        const valueWithChanges = optionsController.oneWayWithChanges("value");
        expect(value.peek()).toBe("123");
        expect(valueWithChanges.peek()).toStrictEqual({
            changes: null,
            value: "123"
        })
    }))
}));
