/**
 * DevExtreme (esm/__internal/grids/new/grid_core/filtering/filter_sync/controller.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import {
    equalByValue
} from "../../../../../../core/utils/common";
import {
    batch,
    effect
} from "@preact/signals-core";
import {
    getMatchedConditions
} from "../../../../../filter_builder/m_utils";
import {
    SearchController
} from "../../../../../grids/new/grid_core/search/index";
import {
    ColumnsController
} from "../../columns_controller/index";
import {
    getColumnByIndexOrName
} from "../../columns_controller/utils";
import {
    HeaderFilterController
} from "../header_filter/index";
import {
    getColumnIdentifier,
    isColumnFilterable
} from "../header_filter/utils";
import {
    FilterController
} from "../index";
import {
    getFilterType,
    getFilterValues,
    mergeFilterPanelWithHeaderFilterValues
} from "./utils";
const FILTER_DEEP_COMPARISON_OPTS = {
    maxDepth: 6,
    strict: true
};
export class FilterSyncController {
    constructor(columnsController, filterController, headerFilterController, searchController) {
        this.columnsController = columnsController;
        this.filterController = filterController;
        this.headerFilterController = headerFilterController;
        this.searchController = searchController;
        this.previousFilterPanelValue = null;
        this.previousFilterPanelEnabled = this.filterController.filterPanelFilterEnabled.peek();
        this.previousHeaderFilterInfoArray = [];
        effect((() => {
            const filterPanelValue = this.filterController.filterValueOption.value;
            const isFilterPanelEnabled = this.filterController.filterPanelFilterEnabled.value;
            if (equalByValue(this.previousFilterPanelValue, filterPanelValue, FILTER_DEEP_COMPARISON_OPTS) && this.previousFilterPanelEnabled === isFilterPanelEnabled) {
                return
            }
            this.previousFilterPanelValue = filterPanelValue;
            this.previousFilterPanelEnabled = isFilterPanelEnabled;
            const isSyncEnabled = this.filterController.filterSyncEnabled.peek();
            if (!isSyncEnabled) {
                return
            }
            if (!isFilterPanelEnabled || null === filterPanelValue) {
                this.headerFilterController.clearHeaderFilters();
                this.previousHeaderFilterInfoArray = this.headerFilterController.headerFilterInfoArray.peek();
                return
            }
            this.handleFilterPanelSync(filterPanelValue);
            this.previousHeaderFilterInfoArray = this.headerFilterController.headerFilterInfoArray.peek()
        }));
        effect((() => {
            const headerFilterInfoArray = this.headerFilterController.headerFilterInfoArray.value;
            if (equalByValue(this.previousHeaderFilterInfoArray, headerFilterInfoArray, FILTER_DEEP_COMPARISON_OPTS)) {
                return
            }
            this.previousHeaderFilterInfoArray = headerFilterInfoArray;
            const isSyncEnabled = this.filterController.filterSyncEnabled.peek();
            if (!isSyncEnabled) {
                return
            }
            const filterPanelValue = this.filterController.filterPanelValue.peek() ?? [];
            const newFilterPanelValue = mergeFilterPanelWithHeaderFilterValues(filterPanelValue, headerFilterInfoArray);
            if (equalByValue(filterPanelValue, newFilterPanelValue, FILTER_DEEP_COMPARISON_OPTS)) {
                return
            }
            this.handleHeaderFilterSync(newFilterPanelValue);
            this.previousFilterPanelValue = newFilterPanelValue
        }))
    }
    clearFilters() {
        batch((() => {
            this.searchController.searchTextOption.value = "";
            this.filterController.filterValueOption.value = null;
            this.headerFilterController.clearHeaderFilters()
        }))
    }
    handleFilterPanelSync(filterPanelValue) {
        const sourceColumns = this.columnsController.columns.peek();
        this.columnsController.updateColumns((columns => columns.map((column => {
            const sourceColumn = getColumnByIndexOrName(sourceColumns, column.name);
            if (!isColumnFilterable(sourceColumn)) {
                return column
            }
            const columnId = getColumnIdentifier(column);
            const filterConditions = getMatchedConditions(filterPanelValue, columnId);
            const filterType = getFilterType(filterConditions);
            const filterValues = filterType ? getFilterValues(filterConditions) : void 0;
            return _extends({}, column, {
                filterType: filterType,
                filterValues: filterValues
            })
        }))))
    }
    handleHeaderFilterSync(newFilterPanelValue) {
        const normalizedValue = !(null !== newFilterPanelValue && void 0 !== newFilterPanelValue && newFilterPanelValue.length) ? null : newFilterPanelValue;
        batch((() => {
            this.filterController.filterValueOption.value = normalizedValue;
            this.filterController.filterPanelFilterEnabled.value = true
        }))
    }
}
FilterSyncController.dependencies = [ColumnsController, FilterController, HeaderFilterController, SearchController];
