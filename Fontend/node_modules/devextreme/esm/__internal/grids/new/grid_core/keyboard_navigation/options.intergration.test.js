/**
 * DevExtreme (esm/__internal/grids/new/grid_core/keyboard_navigation/options.intergration.test.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import {
    afterEach,
    describe,
    expect,
    it,
    jest
} from "@jest/globals";
import $ from "../../../../../core/renderer";
import CardView from "../../../../grids/new/card_view/widget";
import {
    rerender
} from "inferno";
const SELECTORS = {
    cardView: ".dx-cardview",
    headerPanelContent: ".dx-cardview-headerpanel-content",
    headerItem: ".dx-cardview-header-item",
    cardContainer: ".dx-cardview-content",
    card: ".dx-cardview-card",
    cardContent: ".dx-cardview-card-content"
};
const ATTRS = {
    focusDecoy: "data-dx-focus-decoy",
    focusTrapContent: "data-dx-focus-trap-content"
};
const rootQuerySelector = selector => document.body.querySelector(selector);
const setup = function() {
    let options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const container = document.createElement("div");
    const {
        body: body
    } = document;
    body.append(container);
    const cardView = new CardView(container, options);
    rerender();
    return {
        container: container,
        cardView: cardView
    }
};
const baseConfig = {
    dataSource: new Array(6).fill(null).map(((_, idx) => ({
        id: idx
    }))),
    keyExpr: "id",
    columns: ["id"]
};
describe("Options", (() => {
    afterEach((() => {
        var _$;
        const cardView = rootQuerySelector(SELECTORS.cardView);
        null === (_$ = $(cardView ?? void 0)) || void 0 === _$ || _$.dxCardView("dispose")
    }));
    describe("KeyboardNavigation", (() => {
        describe("enabled: true", (() => {
            it("header items should contain tabindex=0", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    }
                }));
                const headerItem = container.querySelector(SELECTORS.headerItem);
                expect(null === headerItem || void 0 === headerItem ? void 0 : headerItem.getAttribute("tabindex")).toBe("0")
            }));
            it("header items container should render focus decoys", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    }
                }));
                const headerPanelContent = container.querySelector(SELECTORS.headerPanelContent);
                const parentContainer = null === headerPanelContent || void 0 === headerPanelContent ? void 0 : headerPanelContent.parentElement;
                const firstDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.firstElementChild;
                const lastDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.lastElementChild;
                expect(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute("tabindex")).toBe("0");
                expect(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute(ATTRS.focusDecoy)).toBe("true");
                expect(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute("tabindex")).toBe("0");
                expect(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute(ATTRS.focusDecoy)).toBe("true")
            }));
            it("cards should contain tabindex=0", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    }
                }));
                const card = container.querySelector(SELECTORS.card);
                expect(null === card || void 0 === card ? void 0 : card.getAttribute("tabindex")).toBe("0")
            }));
            it("card content should render focus trap container", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    }
                }));
                const cardContent = container.querySelector(SELECTORS.cardContent);
                const focusTrapNode = null === cardContent || void 0 === cardContent ? void 0 : cardContent.parentElement;
                expect(null === focusTrapNode || void 0 === focusTrapNode ? void 0 : focusTrapNode.getAttribute(ATTRS.focusTrapContent)).toBe("true")
            }));
            it("card content should render focus decoys", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    }
                }));
                const cardContent = container.querySelector(SELECTORS.cardContent);
                const parentContainer = null === cardContent || void 0 === cardContent ? void 0 : cardContent.parentElement;
                const firstDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.firstElementChild;
                const lastDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.lastElementChild;
                expect(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute("tabindex")).toBe("0");
                expect(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute(ATTRS.focusDecoy)).toBe("true");
                expect(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute("tabindex")).toBe("0");
                expect(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute(ATTRS.focusDecoy)).toBe("true")
            }));
            it("cards container should render focus decoys", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    }
                }));
                const cardsContainer = container.querySelector(SELECTORS.cardContainer);
                const parentContainer = null === cardsContainer || void 0 === cardsContainer ? void 0 : cardsContainer.parentNode;
                const firstDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.firstElementChild;
                const lastDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.lastElementChild;
                expect(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute("tabindex")).toBe("0");
                expect(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute("tabindex")).toBe("0")
            }))
        }));
        describe("enabled: false", (() => {
            it("header items should not contain tabindex", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: false
                    }
                }));
                const headerItem = container.querySelector(SELECTORS.headerItem);
                expect(null === headerItem || void 0 === headerItem ? void 0 : headerItem.getAttribute("tabindex")).toBe(null)
            }));
            it("header items container should not has active focus decoys", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: false
                    }
                }));
                const headerPanelContent = container.querySelector(SELECTORS.headerPanelContent);
                const parentContainer = null === headerPanelContent || void 0 === headerPanelContent ? void 0 : headerPanelContent.parentElement;
                const firstDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.firstElementChild;
                const lastDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.lastElementChild;
                expect(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute("tabindex")).toBe(null);
                expect(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute(ATTRS.focusDecoy)).toBe("false");
                expect(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute("tabindex")).toBe(null);
                expect(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute(ATTRS.focusDecoy)).toBe("false")
            }));
            it("cards should not contain tabindex", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: false
                    }
                }));
                const card = container.querySelector(SELECTORS.card);
                expect(null === card || void 0 === card ? void 0 : card.getAttribute("tabindex")).toBe(null)
            }));
            it("card content should render focus trap container", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: false
                    }
                }));
                const cardContent = container.querySelector(SELECTORS.cardContent);
                const focusTrapNode = null === cardContent || void 0 === cardContent ? void 0 : cardContent.parentElement;
                expect(null === focusTrapNode || void 0 === focusTrapNode ? void 0 : focusTrapNode.getAttribute(ATTRS.focusTrapContent)).toBe("false")
            }));
            it("card content should not has active focus decoys", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: false
                    }
                }));
                const cardContent = container.querySelector(SELECTORS.cardContent);
                const parentContainer = null === cardContent || void 0 === cardContent ? void 0 : cardContent.parentElement;
                const firstDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.firstElementChild;
                const lastDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.lastElementChild;
                expect(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute("tabindex")).toBe(null);
                expect(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute(ATTRS.focusDecoy)).toBe("false");
                expect(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute("tabindex")).toBe(null);
                expect(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute(ATTRS.focusDecoy)).toBe("false")
            }));
            it("cards container should not render focus decoys", (() => {
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: false
                    }
                }));
                const cardsContainer = container.querySelector(SELECTORS.cardContainer);
                const parentContainer = null === cardsContainer || void 0 === cardsContainer ? void 0 : cardsContainer.parentNode;
                const firstDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.firstElementChild;
                const lastDecoy = null === parentContainer || void 0 === parentContainer ? void 0 : parentContainer.lastElementChild;
                expect(null === firstDecoy || void 0 === firstDecoy ? void 0 : firstDecoy.getAttribute("tabindex")).toBe(null);
                expect(null === lastDecoy || void 0 === lastDecoy ? void 0 : lastDecoy.getAttribute("tabindex")).toBe(null)
            }))
        }));
        describe("onKeyDown", (() => {
            it("common API contract test", (() => {
                const callbackMock = jest.fn();
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    },
                    onKeyDown: callbackMock
                }));
                const headerItem = container.querySelector(SELECTORS.headerItem);
                null === headerItem || void 0 === headerItem || headerItem.dispatchEvent(new KeyboardEvent("keydown", {
                    key: "a",
                    bubbles: true
                }));
                expect(callbackMock).toHaveBeenCalledTimes(1);
                const [
                    [{
                        handled: handled,
                        event: event,
                        element: element,
                        component: component
                    }]
                ] = callbackMock.mock.calls;
                expect(handled).toBe(false);
                expect(event).toStrictEqual(expect.any(KeyboardEvent));
                expect(element).toStrictEqual(expect.any(HTMLDivElement));
                expect(component).toStrictEqual(expect.any(CardView))
            }));
            it.each(["Escape", " ", "ArrowDown", "ArrowUp", "B"])('should be called with unhandled events on header item: "%s"', (key => {
                const callbackMock = jest.fn();
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    },
                    onKeyDown: callbackMock
                }));
                const headerItem = container.querySelector(SELECTORS.headerItem);
                null === headerItem || void 0 === headerItem || headerItem.dispatchEvent(new KeyboardEvent("keydown", {
                    key: key,
                    bubbles: true
                }));
                expect(callbackMock).toHaveBeenCalledTimes(1);
                const [
                    [{
                        handled: handled,
                        event: {
                            key: eventKey
                        }
                    }]
                ] = callbackMock.mock.calls;
                expect(handled).toBe(false);
                expect(eventKey).toBe(key)
            }));
            it.each(["ArrowRight", "ArrowLeft", "Enter"])('should be called with handled events on header item: "%s"', (key => {
                const callbackMock = jest.fn();
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    },
                    onKeyDown: callbackMock
                }));
                const headerItem = container.querySelector(SELECTORS.headerItem);
                null === headerItem || void 0 === headerItem || headerItem.dispatchEvent(new KeyboardEvent("keydown", {
                    key: key,
                    bubbles: true
                }));
                expect(callbackMock).toHaveBeenCalledTimes(1);
                expect(callbackMock).toHaveBeenCalledTimes(1);
                const [
                    [{
                        handled: handled,
                        event: {
                            key: eventKey
                        }
                    }]
                ] = callbackMock.mock.calls;
                expect(handled).toBe(true);
                expect(eventKey).toBe(key)
            }));
            it.each(["a", " "])('should be called with unhandled events on card: "%s"', (key => {
                const callbackMock = jest.fn();
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    },
                    onKeyDown: callbackMock
                }));
                const card = container.querySelector(SELECTORS.headerItem);
                null === card || void 0 === card || card.dispatchEvent(new KeyboardEvent("keydown", {
                    key: key,
                    bubbles: true
                }));
                expect(callbackMock).toHaveBeenCalledTimes(1);
                const [
                    [{
                        handled: handled,
                        event: {
                            key: eventKey
                        }
                    }]
                ] = callbackMock.mock.calls;
                expect(handled).toBe(false);
                expect(eventKey).toBe(key)
            }));
            it.each(["ArrowRight", "ArrowLeft", "Enter"])('should be called with handled events on card: "%s"', (key => {
                const callbackMock = jest.fn();
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    },
                    onKeyDown: callbackMock
                }));
                const card = container.querySelector(SELECTORS.headerItem);
                null === card || void 0 === card || card.dispatchEvent(new KeyboardEvent("keydown", {
                    key: key,
                    bubbles: true
                }));
                expect(callbackMock).toHaveBeenCalledTimes(1);
                const [
                    [{
                        handled: handled,
                        event: {
                            key: eventKey
                        }
                    }]
                ] = callbackMock.mock.calls;
                expect(handled).toBe(true);
                expect(eventKey).toBe(key)
            }))
        }));
        describe("onFocusedCardChanged", (() => {
            it("common API contract test", (() => {
                const callbackMock = jest.fn();
                const {
                    container: container
                } = setup(_extends({}, baseConfig, {
                    keyboardNavigation: {
                        enabled: true
                    },
                    onFocusedCardChanged: callbackMock
                }));
                const cardElement = container.querySelector(SELECTORS.card);
                null === cardElement || void 0 === cardElement || cardElement.dispatchEvent(new KeyboardEvent("keydown", {
                    key: "ArrowRight",
                    bubbles: true
                }));
                expect(callbackMock).toHaveBeenCalledTimes(1);
                const [
                    [{
                        cardIndex: cardIndex,
                        card: card,
                        element: element,
                        component: component
                    }]
                ] = callbackMock.mock.calls;
                expect(cardIndex).toEqual(1);
                expect(card).toMatchSnapshot();
                expect(element).toStrictEqual(expect.any(HTMLDivElement));
                expect(component).toStrictEqual(expect.any(CardView))
            }));
            it.each([{
                idx: 0,
                keys: ["ArrowRight", "ArrowRight"],
                path: [1, 2]
            }, {
                idx: 1,
                keys: ["ArrowRight", "ArrowLeft"],
                path: [1, 0]
            }, {
                idx: 2,
                keys: ["ArrowRight", "ArrowLeft"],
                path: [1, 0]
            }, {
                idx: 3,
                keys: ["ArrowDown", "ArrowRight"],
                path: [3, 4]
            }, {
                idx: 4,
                keys: ["ArrowDown", "ArrowUp"],
                path: [3, 0]
            }, {
                idx: 4,
                keys: ["ArrowDown", "ArrowRight", "ArrowDown", "ArrowLeft"],
                path: [3, 4, 7, 6]
            }, {
                idx: 4,
                keys: ["ArrowRight", "ArrowRight", "ArrowRight", "ArrowRight"],
                path: [1, 2]
            }, {
                idx: 4,
                keys: ["ArrowLeft", "ArrowLeft", "ArrowLeft", "ArrowLeft"],
                path: []
            }, {
                idx: 4,
                keys: ["ArrowDown", "ArrowDown", "ArrowDown", "ArrowDown"],
                path: [3, 6]
            }, {
                idx: 4,
                keys: ["ArrowUp", "ArrowUp", "ArrowUp", "ArrowUp"],
                path: []
            }])("should fire event after each card focus change -> case #$idx", (_ref => {
                let {
                    keys: keys,
                    path: path
                } = _ref;
                const callbackMock = jest.fn();
                const {
                    container: container
                } = setup({
                    dataSource: new Array(9).fill(null).map(((_, idx) => ({
                        id: idx
                    }))),
                    keyExpr: "id",
                    columns: ["id"],
                    keyboardNavigation: {
                        enabled: true
                    },
                    paging: {
                        pageSize: 9
                    },
                    onFocusedCardChanged: callbackMock
                });
                const cardElement = container.querySelector(SELECTORS.card);
                keys.forEach((key => {
                    null === cardElement || void 0 === cardElement || cardElement.dispatchEvent(new KeyboardEvent("keydown", {
                        key: key,
                        bubbles: true
                    }))
                }));
                const result = callbackMock.mock.calls.flat().map((_ref2 => {
                    let {
                        cardIndex: cardIndex
                    } = _ref2;
                    return cardIndex
                }));
                expect(result).toStrictEqual(path)
            }))
        }))
    }))
}));
