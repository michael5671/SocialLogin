/**
 * DevExtreme (esm/__internal/grids/new/grid_core/filtering/header_filter/utils.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
const _excluded = ["texts", "visible"];
import errors from "../../../../../../core/errors";
import {
    isDefined
} from "../../../../../../core/utils/type";
import filterUtils from "../../../../../../ui/shared/filtering";
import gridCoreUtils from "../../../../../grids/grid_core/m_utils";
export const mergeColumnHeaderFilterOptions = (column, rootOptions) => {
    var _column$headerFilter;
    const _ref = rootOptions ?? {},
        restRootOptions = _objectWithoutPropertiesLoose(_ref, _excluded);
    return _extends({}, column, {
        allowHeaderFiltering: !!(null !== rootOptions && void 0 !== rootOptions && rootOptions.visible) && !!(null !== column && void 0 !== column && column.allowFiltering) && !!(null !== column && void 0 !== column && column.allowHeaderFiltering),
        headerFilter: _extends({}, restRootOptions, null === column || void 0 === column ? void 0 : column.headerFilter, {
            search: _extends({}, null === restRootOptions || void 0 === restRootOptions ? void 0 : restRootOptions.search, null === column || void 0 === column || null === (_column$headerFilter = column.headerFilter) || void 0 === _column$headerFilter ? void 0 : _column$headerFilter.search)
        })
    })
};
export const getColumnIdentifier = column => column.name ?? column.dataField;
export const getColumnName = column => {
    const name = getColumnIdentifier(column);
    if (!isDefined(name)) {
        throw errors.Error("E1049", column.caption)
    }
    return name
};
export const getFilterOperator = (values, filterType) => {
    const isInclude = !filterType || "include" === filterType;
    const isValueArray = Array.isArray(values);
    switch (true) {
        case isValueArray && isInclude:
            return "anyof";
        case isValueArray && !isInclude:
            return "noneof";
        case !isValueArray && isInclude:
            return "=";
        case !isValueArray && !isInclude:
            return "<>";
        default:
            throw new Error("Invalid state")
    }
};
const isFilteringAllowed = column => column.allowFiltering || column.allowHeaderFiltering;
export const isColumnFilterable = column => isFilteringAllowed(column);
export const needCreateHeaderFilter = column => {
    const values = column.filterValues;
    const hasSelectedItems = isDefined(values) && values.length > 0;
    return isFilteringAllowed(column) && hasSelectedItems
};
const getFilterExpression = (filterValues, column) => {
    var _column$headerFilter2;
    const columnName = getColumnName(column);
    const hasGroupInterval = !!(null !== (_column$headerFilter2 = column.headerFilter) && void 0 !== _column$headerFilter2 && _column$headerFilter2.groupInterval);
    const needNormalizeFilterValues = 1 === (null === filterValues || void 0 === filterValues ? void 0 : filterValues.length) && !hasGroupInterval;
    const normalizedFilterValues = needNormalizeFilterValues ? filterValues[0] : filterValues;
    const filterOperator = getFilterOperator(normalizedFilterValues, column.filterType);
    return [columnName, filterOperator, normalizedFilterValues]
};
export const getHeaderFilterValuesType = column => {
    var _column$headerFilter3;
    const {
        filterValues: filterValues
    } = column;
    if (!(null !== filterValues && void 0 !== filterValues && filterValues.length)) {
        return "empty"
    }
    const [firstFilterItem] = filterValues;
    const hasGroupInterval = !!filterUtils.getGroupInterval(column);
    const hasCustomDataSource = !!(null !== (_column$headerFilter3 = column.headerFilter) && void 0 !== _column$headerFilter3 && _column$headerFilter3.dataSource);
    const isSingleValue = 1 === filterValues.length && !Array.isArray(firstFilterItem) && (!hasGroupInterval && !hasCustomDataSource || 1 === filterValues.length && null === firstFilterItem);
    return isSingleValue ? "single-value" : "values-or-condition"
};
export const getHeaderFilterInfo = column => {
    if (!isFilteringAllowed(column)) {
        return null
    }
    const columnId = getColumnIdentifier(column);
    const headerFilterValueType = getHeaderFilterValuesType(column);
    if ("empty" === headerFilterValueType) {
        return {
            type: "empty",
            columnId: columnId,
            filterType: "include",
            filterValues: [],
            composedFilterValues: []
        }
    }
    const {
        filterType: filterType,
        filterValues: filterValues
    } = column;
    const normalizedFilterType = filterType ?? "include";
    const normalizedFilterValues = Array.isArray(filterValues) ? filterValues : [filterValues];
    const filterValuesWithExpressions = normalizedFilterValues.filter((value => Array.isArray(value)));
    const filterValuesWithoutExpressions = normalizedFilterValues.filter((value => !Array.isArray(value)));
    const filterExpression = filterValuesWithoutExpressions.length ? [getFilterExpression(filterValuesWithoutExpressions, column)] : [];
    const composedFilterValues = gridCoreUtils.combineFilters([...filterExpression, ...filterValuesWithExpressions], "or");
    return {
        type: headerFilterValueType,
        columnId: columnId,
        filterType: normalizedFilterType,
        filterValues: filterValues,
        composedFilterValues: composedFilterValues
    }
};
export const getHeaderFilterInfoArray = columns => columns.map((column => getHeaderFilterInfo(column))).filter((info => !!info));
export const getComposedHeaderFilter = headerFilterInfoArray => headerFilterInfoArray.filter((_ref2 => {
    let {
        type: type
    } = _ref2;
    return "empty" !== type
})).reduce(((result, _ref3, idx, infoArray) => {
    let {
        composedFilterValues: composedFilterValues
    } = _ref3;
    result.push(composedFilterValues);
    if (idx < infoArray.length - 1) {
        result.push("and")
    }
    return result
}), []);
