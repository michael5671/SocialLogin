/**
 * DevExtreme (esm/__internal/grids/new/grid_core/sorting_controller/controller.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import {
    batch,
    computed
} from "@preact/signals-core";
import {
    ColumnsController
} from "../columns_controller/index";
import {
    getColumnIndexByName
} from "../columns_controller/utils";
import {
    OptionsController
} from "../options_controller/options_controller";
import {
    getNextSortOrder,
    sortOrderDelegate
} from "./utils";
export class SortingController {
    constructor(options, columnsController) {
        this.options = options;
        this.columnsController = columnsController;
        this.ascendingText = this.options.oneWay("sorting.ascendingText");
        this.clearText = this.options.oneWay("sorting.clearText");
        this.descendingText = this.options.oneWay("sorting.descendingText");
        this.mode = this.options.oneWay("sorting.mode");
        this._showSortIndexes = this.options.oneWay("sorting.showSortIndexes");
        this.sortedColumns = computed((() => this.columnsController.visibleColumns.value.filter((column => column.sortOrder))));
        this.orderedSortedColumns = computed((() => {
            const columns = this.sortedColumns.value;
            const mode = this.mode.value;
            const result = columns.sort(sortOrderDelegate);
            if ("multiple" !== mode && this.areColumnsInitialized) {
                return result
            }
            if (!this.areColumnsInitialized) {
                this.areColumnsInitialized = true;
                result.forEach(((col, idx) => {
                    this.columnsController.columnOption(col, "sortIndex", idx)
                }))
            }
            return result
        }));
        this.showSortIndexes = computed((() => {
            const _showSortIndexes = this._showSortIndexes.value;
            const sortedColumns = this.sortedColumns.value;
            if (!_showSortIndexes) {
                return _showSortIndexes
            }
            return sortedColumns.length > 1
        }));
        this.sortParameters = computed((() => {
            const columns = this.orderedSortedColumns.value;
            const result = [];
            columns.forEach((c => {
                const sortItem = {
                    selector: c.calculateSortValue ?? c.dataField ?? c.selector,
                    desc: "desc" === c.sortOrder
                };
                if (c.sortingMethod) {
                    sortItem.compare = c.sortingMethod.bind(c)
                }
                result.push(sortItem)
            }));
            return result
        }));
        this.areColumnsInitialized = false
    }
    clearSorting() {
        this.columnsController.updateColumns((columns => columns.map((c => {
            delete c.sortOrder;
            delete c.sortIndex;
            return c
        }))))
    }
    onSingleModeSortClick(column, e) {
        if (!column.allowSorting) {
            return
        }
        const isCtrl = e.ctrlKey || e.metaKey;
        const isClearSorting = !!column.sortOrder && isCtrl;
        if (isClearSorting) {
            this.clearSorting();
            return
        }
        const isClearSortingRequired = !column.sortOrder && !isCtrl || this.sortedColumns.peek().length > 1;
        const nextSortOrder = getNextSortOrder(column.sortOrder, isCtrl);
        this.onSingleModeSortCore(column, isClearSortingRequired, nextSortOrder)
    }
    onSingleModeSortCore(column, isClearSortingRequired, nextSortOrder) {
        batch((() => {
            if (isClearSortingRequired) {
                this.clearSorting()
            }
            this.columnsController.columnOption(column, "sortOrder", nextSortOrder)
        }))
    }
    onMultipleModeSortClick(column, e) {
        if (!column.allowSorting) {
            return
        }
        const isCtrl = e.ctrlKey || e.metaKey;
        const hasNothingToChange = !column.sortOrder && isCtrl && !e.shiftKey;
        if (hasNothingToChange) {
            return
        }
        const nextSortOrder = getNextSortOrder(column.sortOrder, isCtrl);
        const isClearSortingRequired = !isCtrl && !e.shiftKey;
        this.onMultipleModeSortCore(column, isClearSortingRequired, nextSortOrder)
    }
    onMultipleModeSortCore(column, isClearSortingRequired, nextSortOrder) {
        batch((() => {
            if (isClearSortingRequired) {
                this.clearSorting()
            }
            this.updateColumnSortOrder(column, nextSortOrder)
        }))
    }
    updateColumnSortOrder(column, nextSortOrder) {
        const needChanges = "multiple" === this.mode.peek();
        if (!needChanges) {
            return
        }
        this.columnsController.updateColumns((columns => {
            const newColumns = [...columns];
            let needNormalizing = false;
            const orderedSortedColumns = this.orderedSortedColumns.peek();
            const orderedIndex = getColumnIndexByName(orderedSortedColumns, column.name);
            const commonIndex = getColumnIndexByName(newColumns, column.name);
            newColumns[commonIndex].sortOrder = nextSortOrder;
            if (!!nextSortOrder && -1 === orderedIndex) {
                orderedSortedColumns.push(newColumns[commonIndex]);
                needNormalizing = true
            }
            if (!nextSortOrder && orderedIndex > -1) {
                delete newColumns[commonIndex].sortOrder;
                delete newColumns[commonIndex].sortIndex;
                orderedSortedColumns.splice(orderedIndex, 1);
                needNormalizing = true
            }
            if (needNormalizing) {
                let counter = 0;
                orderedSortedColumns.forEach((c => {
                    const index = getColumnIndexByName(newColumns, c.name);
                    if (newColumns[index].sortIndex !== counter) {
                        newColumns[index] = _extends({}, newColumns[index], {
                            sortIndex: counter
                        })
                    }
                    counter += 1
                }))
            }
            return newColumns
        }))
    }
}
SortingController.dependencies = [OptionsController, ColumnsController];
