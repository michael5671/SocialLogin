/**
 * DevExtreme (esm/__internal/grids/new/grid_core/filtering/header_filter/legacy_header_filter.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import {
    Deferred
} from "../../../../../../core/utils/deferred";
import {
    isDefined,
    isFunction,
    isObject
} from "../../../../../../core/utils/type";
import filteringUtils from "../../../../../../ui/shared/filtering";
import {
    extend
} from "../../../../../core/utils/m_extend";
import {
    normalizeDataSourceOptions as oldNormalizeDataSourceOptions
} from "../../../../../data/data_source/m_utils";
import {
    convertDataFromUTCToLocal,
    getFormatOptions,
    isUTCFormat
} from "../../../../../grids/grid_core/header_filter/m_header_filter";
import {
    updateHeaderFilterItemSelectionState
} from "../../../../../grids/grid_core/header_filter/m_header_filter_core";
import gridCoreUtils from "../../../../../grids/grid_core/m_utils";
export const getHeaderItemText = (displayValue, column, currentLevel, headerFilterOptions) => {
    let text = gridCoreUtils.formatValue(displayValue, getFormatOptions(displayValue, column, currentLevel));
    if (!text) {
        var _headerFilterOptions$;
        text = (null === headerFilterOptions || void 0 === headerFilterOptions || null === (_headerFilterOptions$ = headerFilterOptions.texts) || void 0 === _headerFilterOptions$ ? void 0 : _headerFilterOptions$.emptyValue) ?? "(Blank)"
    }
    return text
};
const _updateSelectedState = (items, column) => {
    let i = items.length;
    const isExclude = "exclude" === column.filterType;
    while (i--) {
        const item = items[i];
        if ("items" in items[i]) {
            _updateSelectedState(items[i].items, column)
        }
        updateHeaderFilterItemSelectionState(item, gridCoreUtils.getIndexByKey(items[i].value, column.filterValues, null) > -1, isExclude)
    }
};
const _normalizeGroupItem = (item, currentLevel, options) => {
    let value;
    let displayValue;
    const {
        path: path
    } = options;
    const {
        valueSelector: valueSelector
    } = options;
    const {
        displaySelector: displaySelector
    } = options;
    const {
        column: column
    } = options;
    if (valueSelector && displaySelector) {
        value = valueSelector(item);
        displayValue = displaySelector(item)
    } else {
        value = item.key;
        displayValue = value
    }
    if (!isObject(item)) {
        item = {}
    } else {
        item = extend({}, item)
    }
    path.push(value);
    if (1 === path.length) {
        item.value = path[0]
    } else {
        item.value = path.join("/")
    }
    item.text = getHeaderItemText(displayValue, column, currentLevel, options.headerFilterOptions);
    return item
};
const _processGroupItems = (groupItems, currentLevel, path, options) => {
    const {
        level: level
    } = options;
    path = path || [];
    currentLevel = currentLevel || 0;
    for (let i = 0; i < groupItems.length; i++) {
        groupItems[i] = _normalizeGroupItem(groupItems[i], currentLevel, {
            column: options.column,
            headerFilterOptions: options.headerFilterOptions,
            path: path
        });
        if ("items" in groupItems[i]) {
            if (currentLevel === level || !isDefined(groupItems[i].value)) {
                delete groupItems[i].items
            } else {
                _processGroupItems(groupItems[i].items, currentLevel + 1, path, options)
            }
        }
        path.pop()
    }
};
export const getDataSourceOptions = (storeLoadAdapter, popupOptions, headerFilterOptions, filter) => {
    var _column$headerFilter;
    const {
        column: column
    } = popupOptions;
    if (!storeLoadAdapter) {
        return
    }
    const {
        grouping: localGrouping
    } = storeLoadAdapter.getLocalLoadOperations();
    const remoteGrouping = !localGrouping;
    const group = gridCoreUtils.getHeaderFilterGroupParameters(column, remoteGrouping);
    const headerFilterDataSource = null === (_column$headerFilter = column.headerFilter) || void 0 === _column$headerFilter ? void 0 : _column$headerFilter.dataSource;
    const options = {};
    if (isDefined(headerFilterDataSource) && !isFunction(headerFilterDataSource)) {
        options.dataSource = oldNormalizeDataSourceOptions(headerFilterDataSource)
    } else {
        const cutoffLevel = Array.isArray(group) ? group.length - 1 : 0;
        options.dataSource = {
            filter: filter,
            group: group,
            useDefaultSearch: true,
            load: loadOptions => {
                const d = new Deferred;
                loadOptions.dataField = column.dataField || column.name;
                storeLoadAdapter.load(loadOptions).done((data => {
                    const convertUTCDates = remoteGrouping && isUTCFormat(column.serializationFormat) && cutoffLevel > 3;
                    if (convertUTCDates) {
                        data = convertDataFromUTCToLocal(data, column)
                    }
                    _processGroupItems(data, null, null, {
                        level: cutoffLevel,
                        column: column,
                        headerFilterOptions: headerFilterOptions
                    });
                    d.resolve(data)
                })).fail(d.reject);
                return d
            }
        }
    }
    if (isFunction(headerFilterDataSource)) {
        headerFilterDataSource.call(column, options)
    }
    const origPostProcess = options.dataSource.postProcess;
    options.dataSource.postProcess = data => {
        let items = data;
        items = (null === origPostProcess || void 0 === origPostProcess ? void 0 : origPostProcess.call(this, items)) || items;
        _updateSelectedState(items, _extends({}, column, {
            filterType: popupOptions.filterType,
            filterValues: popupOptions.filterValues
        }));
        return items
    };
    return options.dataSource
};
export const getHeaderFilterListType = column => {
    const groupInterval = filteringUtils.getGroupInterval(column);
    return groupInterval && groupInterval.length > 1 ? "tree" : "list"
};
