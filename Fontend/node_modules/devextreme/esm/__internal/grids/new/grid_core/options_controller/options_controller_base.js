/**
 * DevExtreme (esm/__internal/grids/new/grid_core/options_controller/options_controller_base.js)
 * Version: 25.1.3
 * Build date: Wed Jun 25 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import {
    Component
} from "../../../../../core/component";
import {
    getPathParts
} from "../../../../../core/utils/data";
import {
    computed,
    effect,
    signal
} from "@preact/signals-core";
import {
    extend
} from "../../../../core/utils/m_extend";
import {
    TemplateWrapper
} from "../inferno_wrappers/template_wrapper";
import {
    getTreeNodeByPath,
    mergeOptionTrees
} from "../utils/tree/index";

function getOr(cache, key, orElse) {
    if (cache[key]) {
        return cache[key]
    }
    const value = orElse();
    cache[key] = value;
    return value
}
export class OptionsController {
    constructor(component) {
        var _component$_getDefaul;
        this.component = component;
        this.cache = {
            oneWay: {},
            oneWayWithChanges: {},
            twoWay: {},
            action: {},
            template: {}
        };
        this.isControlledMode = false;
        this.initialized = this.component.initialized;
        this.defaults = (null === (_component$_getDefaul = component._getDefaultOptions) || void 0 === _component$_getDefaul ? void 0 : _component$_getDefaul.call(component)) ?? {};
        this.internalOptions = signal({
            options: extend(true, {}, component.option()),
            changes: null
        });
        this.updateIsControlledMode();
        component.on("optionChanged", this.onOptionChangedHandler.bind(this))
    }
    updateIsControlledMode() {
        const isControlledMode = this.component.option("integrationOptions.isControlledMode");
        this.isControlledMode = isControlledMode ?? false
    }
    onOptionChangedHandler(optionChanges) {
        const {
            fullName: fullName
        } = optionChanges;
        this.updateIsControlledMode();
        this.updateInternalOptionsState(fullName, optionChanges)
    }
    updateInternalOptionsState(optionFullName) {
        let changes = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        const pathParts = getPathParts(optionFullName);
        this.internalOptions.value = {
            options: mergeOptionTrees(this.internalOptions.peek().options, this.component.option(), this.defaults, pathParts),
            changes: changes
        }
    }
    oneWay(name) {
        return getOr(this.cache.oneWay, name, (() => {
            const pathArray = getPathParts(name);
            return computed((() => getTreeNodeByPath(this.internalOptions.value.options, pathArray)))
        }))
    }
    oneWayWithChanges(name) {
        return getOr(this.cache.oneWayWithChanges, name, (() => {
            const pathArray = getPathParts(name);
            return computed((() => {
                const {
                    options: options,
                    changes: changes
                } = this.internalOptions.value;
                return {
                    value: getTreeNodeByPath(options, pathArray),
                    changes: changes
                }
            }))
        }))
    }
    twoWay(name) {
        return getOr(this.cache.twoWay, name, (() => {
            const that = this;
            const obs = signal(this.component.option(name));
            effect((() => {
                obs.value = this.oneWay(name).value
            }));
            return {
                get value() {
                    return obs.value
                },
                set value(value) {
                    const isInitialized = that.initialized.peek();
                    const callbackName = `on${name}Change`;
                    const callback = that.component.option(callbackName);
                    const isControlled = that.isControlledMode && void 0 !== that.component.option(name);
                    if (isControlled) {
                        null === callback || void 0 === callback || callback(value);
                        return
                    }
                    that.component.option(name, value);
                    if (!isInitialized) {
                        that.updateInternalOptionsState(name)
                    }
                    null === callback || void 0 === callback || callback(value)
                },
                peek: () => obs.peek(),
                subscribe() {
                    return obs.subscribe(...arguments)
                },
                toJSON() {
                    return obs.toJSON(...arguments)
                },
                valueOf() {
                    return obs.valueOf(...arguments)
                },
                brand: obs.brand
            }
        }))
    }
    normalizeTemplate(template) {
        return TemplateWrapper(this.component._getTemplate(template))
    }
    template(name) {
        return getOr(this.cache.template, name, (() => {
            const templateOption = this.oneWay(name);
            return computed((() => templateOption.value && this.normalizeTemplate(templateOption.value)))
        }))
    }
    action(name) {
        return getOr(this.cache.action, name, (() => {
            const actionOption = this.oneWay(name);
            return computed((() => {
                actionOption.value;
                return this.component._createActionByOption(name)
            }))
        }))
    }
}
OptionsController.dependencies = [Component];
